<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="BLOG">
    <meta name="keyword" content="pltm">
    <meta name="theme-color" content="#600090">
    <meta name="msapplication-navbutton-color" content="#600090">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="#600090">
    <!-- google-site-verification -->
    <meta name="google-site-verification" content="fgG59EBWTLiWni3UcgCPhkEPiVDNCnLeaocoTWjctOg" />
    <link rel="shortcut icon" href="/images/favicon.png">
    <link rel="alternate" type="application/atom+xml" title="PLTM" href="/atom.xml">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.css">
    <title>
        
        Collection Framework(1)｜PTLM blog
        
    </title>

    <link rel="canonical" href="https://plentymore.github.io/2018/09/09/Collection-Framework-1/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/blog-style.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">
    <!-- Google AdSense -->
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
             google_ad_client: "ca-pub-1771277850135880",
             enable_page_level_ads: true
          });
    </script>
<link rel="stylesheet" href="\assets\css\APlayer.min.css" class="aplayer-style-marker">
<script src="\assets\js\APlayer.min.js" class="aplayer-script-marker"></script>
<script src="\assets\js\Meting.min.js" class="meting-script-marker"></script>
</head>

<style>

    header.intro-header {
        background-image: url('/images/3.jpg')
    }
</style>
<!-- hack iOS CSS :active style -->
<body ontouchstart="" class="animated fadeIn">
<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top " id="nav-top" data-ispost = "true" data-istags="false
" data-ishome = "false" >
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand animated pulse" href="/">
                <span class="brand-logo">
                    PLTM
                </span>
                's Blog
            </a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <!-- /.navbar-collapse -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
					
                    
                        
							
                        <li>
                            <a href="/Tags/">Tags</a>
                        </li>
							
						
                    
                        
							
								
							
						
                    
					
					
						<li>
							<a href="/about">About</a>
						</li>
					
                </ul>
            </div>
        </div>
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
//    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>

<!-- Main Content -->

<!--only post-->


<img class="wechat-title-img" src="https://i.imgur.com/RAwKwAj.jpg">


<style>
    
    header.intro-header {
        background-image: url('https://i.imgur.com/RAwKwAj.jpg');
    }

    
</style>

<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <div class="post-heading">
                    <h1>Collection Framework(1)</h1>
                    
                    <span class="meta">
                         作者 plentymore
                        <span>
                          日期 2018-09-09
                         </span>
                    </span>
                    <div class="tags text-center">
                        
                        <a class="tag" href="/Tags/#Container"
                           title="Container">Container</a>
                        
                        <a class="tag" href="/Tags/#Collection"
                           title="Collection">Collection</a>
                        
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="post-title-haojen">
        <span>
            Collection Framework(1)
        </span>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <!-- Post Container -->
            <div class="col-lg-8 col-lg-offset-1 col-sm-9 post-container">
                
    <div id="aplayer-vUkTDNDA" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="28556280" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div>
<p>关于Java Collection的几个常用实现类的总结</p>
<h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><p>ArrayList实现了List接口，并且实现了该接口的所有可选操作（<code>replaceAll</code>，<code>spliterator</code>，<code>sort</code>）。<br>它的大小是可以动态变化的，相当于一个可变长度的数组，它可以存储任何类型的对象，包括null。</p>
<p> The <tt>size</tt>, <tt>isEmpty</tt>, <tt>get</tt>, <tt>set</tt>,<br>  <tt>iterator</tt>, and <tt>listIterator</tt> operations run in constant<br>  time.  The <tt>add</tt> operation runs in <i>amortized constant time</i>,<br>  that is, adding n elements requires O(n) time.  All of the other operations<br>  run in linear time (roughly speaking). </p>
<p><code>size</code>, <code>isEmpty</code>, <code>get</code>, <code>set</code>, <code>iterator</code>, <code>listIterator</code>这些方法的时间复杂度都是都是O(1)，<br><code>add(E e)</code>的时间复杂度是O(1)，<code>add(int index, E element)</code>的时间复杂度是O(n)，其他的方法大多数都是线性时间复杂度O(n)。</p>
<p>该类不是线程安全的，假设要在多线程环境下使用ArrayList，需要使用外部同步<br>保证对ArrayList的修改对其他线程可见，也可以使用<code>Collections.synchronizedList</code>方法使得ArrayList的实例变成线程安全的，<br>比如<code>List list = Collections.synchronizedList(new ArrayList(...))</code></p>
<h2 id="fail-fast"><a href="#fail-fast" class="headerlink" title="fail-fast"></a>fail-fast</h2><p>在调用<code>iterator</code>或者<code>listIterator</code>创建了一个迭代器对象之后，假如在使用该迭代器访问元素的过程中通过除了迭代器对象的<code>remove</code><br>和<code>add</code>结构化修改了（一般除了set方法外的修改都是结构化修改）ArrayList里面的元素，就会抛出<code>ConcurrentModificationException</code>异常。<br>在没有被正确同步的情况下，该机制有可能会失效。</p>
<h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Default initial capacity. 默认容量为10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Shared empty array instance used for empty instances.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Shared empty array instance used for default sized empty instances. We</span></span><br><span class="line"><span class="comment"> * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span></span><br><span class="line"><span class="comment"> * first element is added.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The array buffer into which the elements of the ArrayList are stored.</span></span><br><span class="line"><span class="comment"> * The capacity of the ArrayList is the length of this array buffer. Any</span></span><br><span class="line"><span class="comment"> * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment"> * will be expanded to DEFAULT_CAPACITY when the first element is added.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The size of the ArrayList (the number of elements it contains).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty list with the specified initial capacity.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity  the initial capacity of the list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span></span><br><span class="line"><span class="comment"> *         is negative</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty list with an initial capacity of ten.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a list containing the elements of the specified</span></span><br><span class="line"><span class="comment"> * collection, in the order they are returned by the collection's</span></span><br><span class="line"><span class="comment"> * iterator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c the collection whose elements are to be placed into this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><ul>
<li><p>public void ensureCapacity(int minCapacity)<br>增加ArrayList的容量</p>
</li>
<li><p>public boolean isEmpty()</p>
</li>
<li><p>public boolean contains(Object o)</p>
</li>
<li><p>public int indexOf(Object o)</p>
</li>
<li><p>public int lastIndexOf(Object o) </p>
</li>
<li><p>public E set(int index, E element)</p>
</li>
<li><p>public E get(int index) </p>
</li>
<li><p>public int size() </p>
</li>
<li><p>public boolean add(E e)</p>
</li>
<li><p>public void add(int index, E element)</p>
</li>
<li><p>public E remove(int index)</p>
</li>
<li><p>public boolean remove(Object o) </p>
</li>
<li><p>public void clear()</p>
</li>
<li><p>public boolean addAll(Collection&lt;? extends E&gt; c) </p>
</li>
<li><p>public boolean addAll(int index, Collection&lt;? extends E&gt; c)<br>从原集合的index位置开始添加c的元素，原集合的index位置后面的元素将移动到最后面</p>
</li>
<li><p>public boolean removeAll(Collection&lt;?&gt; c)</p>
</li>
<li><p>public boolean retainAll(Collection&lt;?&gt; c)<br>交集（仅保留在ArrayList对象和c里面均存在的元素）</p>
</li>
<li><p>public Iterator<e> iterator()</e></p>
</li>
<li><p>public ListIterator<e> listIterator()</e></p>
</li>
</ul>
<h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h1><p><code>Vector</code>类是线程安全的，因此多线程环境下使用<code>Vector</code>不需要外部同步。它的结构和<code>ArrayList</code>类似，<br>可以说它是<code>ArrayList</code>的线程安全的版本。</p>
<h2 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The array buffer into which the components of the vector are</span></span><br><span class="line"><span class="comment"> * stored. The capacity of the vector is the length of this array buffer,</span></span><br><span class="line"><span class="comment"> * and is at least large enough to contain all the vector's elements.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Any array elements following the last element in the Vector are null.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of valid components in this &#123;<span class="doctag">@code</span> Vector&#125; object.</span></span><br><span class="line"><span class="comment"> * Components &#123;<span class="doctag">@code</span> elementData[0]&#125; through</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> elementData[elementCount-1]&#125; are the actual items.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> elementCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The amount by which the capacity of the vector is automatically</span></span><br><span class="line"><span class="comment"> * incremented when its size becomes greater than its capacity.  If</span></span><br><span class="line"><span class="comment"> * the capacity increment is less than or equal to zero, the capacity</span></span><br><span class="line"><span class="comment"> * of the vector is doubled each time it needs to grow.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> capacityIncrement;</span><br></pre></td></tr></table></figure>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty vector with the specified initial capacity and</span></span><br><span class="line"><span class="comment"> * capacity increment.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   initialCapacity     the initial capacity of the vector</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   capacityIncrement   the amount by which the capacity is</span></span><br><span class="line"><span class="comment"> *                              increased when the vector overflows</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span></span><br><span class="line"><span class="comment"> *         is negative</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty vector with the specified initial capacity and</span></span><br><span class="line"><span class="comment"> * with its capacity increment equal to zero.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   initialCapacity   the initial capacity of the vector</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span></span><br><span class="line"><span class="comment"> *         is negative</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty vector so that its internal data array</span></span><br><span class="line"><span class="comment"> * has size &#123;<span class="doctag">@code</span> 10&#125; and its standard capacity increment is</span></span><br><span class="line"><span class="comment"> * zero.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a vector containing the elements of the specified</span></span><br><span class="line"><span class="comment"> * collection, in the order they are returned by the collection's</span></span><br><span class="line"><span class="comment"> * iterator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c the collection whose elements are to be placed into this</span></span><br><span class="line"><span class="comment"> *       vector</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    elementCount = elementData.length;</span><br><span class="line">    <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">    <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">        elementData = Arrays.copyOf(elementData, elementCount, Object[].class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h2><ul>
<li><p>public synchronized void setSize(int newSize)<br>设置链表的elementCount，如果要设置的elementCount比当前的elementCount要大，则往里面填充null对象，否则将清空要设置的大小以外的元素</p>
</li>
<li><p>public synchronized int capacity()<br>获取当前的容量（elementData.length）</p>
</li>
<li><p>public synchronized int size()<br>获取当前存储的元素个数（elementCount）</p>
</li>
<li><p>public synchronized boolean isEmpty()</p>
</li>
<li><p>public Enumeration<e> elements()<br>返回当前存储元素对象的枚举，和Iterator功能差不多，用于遍历存储的元素。</e></p>
</li>
<li><p>public boolean contains(Object o)</p>
</li>
<li><p>public int indexOf(Object o)<br>获取特定对象在链表中首次出现的索引，若元素不在链表中则返回-1</p>
</li>
<li><p>public synchronized int indexOf(Object o, int index)<br>从指定位置（index）开始获取特定对象在链表中首次出现的索引，不存在返回-1</p>
</li>
<li><p>public synchronized int lastIndexOf(Object o)</p>
</li>
<li><p>public synchronized int lastIndexOf(Object o, int index)</p>
</li>
<li><p>public synchronized E elementAt(int index)</p>
</li>
<li><p>public synchronized E firstElement() </p>
</li>
<li><p>public synchronized E lastElement() </p>
</li>
<li><p>public synchronized void setElementAt(E obj, int index)</p>
</li>
<li><p>public synchronized void removeElementAt(int index) </p>
</li>
<li><p>public synchronized void insertElementAt(E obj, int index)</p>
</li>
<li><p>public synchronized void addElement(E obj)<br>添加一个元素到尾部</p>
</li>
<li><p>public synchronized boolean removeElement(Object obj) </p>
</li>
<li><p>public synchronized void removeAllElements()</p>
</li>
<li><p>public synchronized E get(int index) </p>
</li>
<li><p>public synchronized E set(int index, E element)</p>
</li>
<li><p>public synchronized boolean add(E e) </p>
</li>
<li><p>public boolean remove(Object o)</p>
</li>
<li><p>public void add(int index, E element)</p>
</li>
<li><p>public synchronized E remove(int index)</p>
</li>
<li><p>public void clear()</p>
</li>
<li><p>public synchronized boolean containsAll(Collection&lt;?&gt; c)<br>如果链表包含c中的所以元素，则返回true</p>
</li>
<li><p>public synchronized boolean addAll(Collection&lt;? extends E&gt; c)</p>
</li>
<li><p>public synchronized boolean addAll(int index, Collection&lt;? extends E&gt; c) </p>
</li>
<li><p>public synchronized boolean removeAll(Collection&lt;?&gt; c)</p>
</li>
<li><p>public synchronized boolean retainAll(Collection&lt;?&gt; c)<br>取交集（在该链表和c中均包含的元素）</p>
</li>
</ul>
<h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><p>LinkedList实现了List和Deque接口，它允许存放任何类型的对象，包括null，该类不是线程安全的。<br>使用索引去访问存储的元素时，将从第一个节点开始遍历到相对应的节点，而不是直接通过索引就能取出元素，因为底层结构改变了，<br>变成了一个个通过next和prev变量相连接的Node，Node的结构如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="成员变量-2"><a href="#成员变量-2" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;  <span class="comment">//存储的元素个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pointer to first node.</span></span><br><span class="line"><span class="comment"> * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment"> *            (first.prev == null &amp;&amp; first.item != null)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;  <span class="comment">//第一个节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pointer to last node.</span></span><br><span class="line"><span class="comment"> * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment"> *            (last.next == null &amp;&amp; last.item != null)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;  <span class="comment">//最后一个节点</span></span><br></pre></td></tr></table></figure>
<h2 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a list containing the elements of the specified</span></span><br><span class="line"><span class="comment"> * collection, in the order they are returned by the collection's</span></span><br><span class="line"><span class="comment"> * iterator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  c the collection whose elements are to be placed into this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h2><ul>
<li><p>public E getFirst()</p>
</li>
<li><p>public E getLast()</p>
</li>
<li><p>public E removeFirst()</p>
</li>
<li><p>public E removeLast()</p>
</li>
<li><p>public void addFirst(E e)</p>
</li>
<li><p>public void addLast(E e)</p>
</li>
<li><p>public boolean contains(Object o)</p>
</li>
<li><p>public int size()</p>
</li>
<li><p>public boolean add(E e)<br>添加一个元素到链表的尾部</p>
</li>
<li><p>public boolean remove(Object o)<br>移除特定元素（假设有多个相同的元素，将移除在链表最前面出现的元素）</p>
</li>
<li><p>public boolean addAll(Collection&lt;? extends E&gt; c)</p>
</li>
<li><p>public boolean addAll(int index, Collection&lt;? extends E&gt; c)</p>
</li>
<li><p>public void clear()</p>
</li>
<li><p>public E get(int index)</p>
</li>
<li><p>public E set(int index, E element)</p>
</li>
<li><p>public void add(int index, E element)</p>
</li>
<li><p>public E remove(int index) </p>
</li>
<li><p>public int indexOf(Object o)</p>
</li>
<li><p>public int lastIndexOf(Object o)</p>
</li>
<li><p>public E peek()<br>取最后面的元素，只是获取该元素，不移除，当元素不存在时，返回null</p>
</li>
<li><p>public E peekFirst()</p>
</li>
<li><p>public E peekLast() </p>
</li>
<li><p>public E element()<br>和peek方法一样，不过当元素不存在时候，抛出NoSuchElementException</p>
</li>
<li><p>public E poll()<br>获取并移除最后面的元素，当元素不存在时，返回null</p>
</li>
<li><p>public E pollFirst() </p>
</li>
<li><p>public E pollLast()</p>
</li>
<li><p>public E remove()<br>和poll方法一样，不过当元素不存在时候，抛出NoSuchElementException</p>
</li>
<li><p>public boolean offer(E e)<br>添加元素到最后面</p>
</li>
<li><p>public boolean offerFirst(E e)<br>添加元素到最前面</p>
</li>
<li><p>public boolean offerLast(E e)<br>添加元素到最后面 </p>
</li>
<li><p>public void push(E e)<br>添加元素到最前面</p>
</li>
<li><p>public E pop()<br>弹出最前面的元素，push和pop是栈的方法，因为前面的push是添加元素到最前面的，所以现在pop也应该弹出<br>最前面的元素才符合FIFO</p>
</li>
<li><p>public boolean removeFirstOccurrence(Object o)<br>移除第一次出现的特定元素，从fistNode开始到lastNode结束</p>
</li>
<li><p>public boolean removeLastOccurrence(Object o)</p>
</li>
</ul>
<h1 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h1><p>和ArrayList类似，不过它是线程安全的，它对的<code>add</code>和<code>set</code>等操作都将重新复制原来的数组元素并创建新的数组，<br>因此开销非常大，一般只用来遍历和查找元素，如果要频繁地增加或改动元素则不应该使用该类。它允许插入null元素。</p>
<h2 id="成员变量-3"><a href="#成员变量-3" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** The lock protecting all mutators */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The array, accessed only via getArray/setArray. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br></pre></td></tr></table></figure>
<h2 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an empty list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setArray(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a list containing the elements of the specified</span></span><br><span class="line"><span class="comment"> * collection, in the order they are returned by the collection's</span></span><br><span class="line"><span class="comment"> * iterator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c the collection of initially held elements</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] elements;</span><br><span class="line">    <span class="keyword">if</span> (c.getClass() == CopyOnWriteArrayList.class)</span><br><span class="line">        elements = ((CopyOnWriteArrayList&lt;?&gt;)c).getArray();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        elements = c.toArray();</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elements.getClass() != Object[].class)</span><br><span class="line">            elements = Arrays.copyOf(elements, elements.length, Object[].class);</span><br><span class="line">    &#125;</span><br><span class="line">    setArray(elements);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a list holding a copy of the given array.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toCopyIn the array (a copy of this array is used as the</span></span><br><span class="line"><span class="comment"> *        internal array)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified array is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">(E[] toCopyIn)</span> </span>&#123;</span><br><span class="line">    setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h2><p>参考ArrayList</p>
<h1 id="List总结"><a href="#List总结" class="headerlink" title="List总结"></a>List总结</h1><ul>
<li><code>ArrayList</code>不是线程安全的，<code>Vector</code>是线程安全的</li>
<li><code>ArayList</code>的查找操作只需要常数时间，<code>LinkedList</code>则需要线性时间</li>
<li><code>LinkedList</code>同时实现了<code>List</code>和<code>Deque</code>接口</li>
<li><code>List</code>中可以包含重复的元素</li>
<li><code>CopyOnWriteArrayList</code>一般用于多线程中频繁地访问元素的情景</li>
</ul>
<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p><code>HashMap</code>的实现已经在<a href="https://plentymore.github.io/2018/08/14/HashMap/">前几篇博客</a>介绍过了。<br><code>HashMap</code>不是线程安全的，它可以存放null键值对</p>
<h2 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment"> * capacity and load factor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment"> *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment"> * capacity and the default load factor (0.75).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity the initial capacity.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span></span><br><span class="line"><span class="comment"> * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the</span></span><br><span class="line"><span class="comment"> * specified &lt;tt&gt;Map&lt;/tt&gt;.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with</span></span><br><span class="line"><span class="comment"> * default load factor (0.75) and an initial capacity sufficient to</span></span><br><span class="line"><span class="comment"> * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   m the map whose mappings are to be placed in this map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常用方法-4"><a href="#常用方法-4" class="headerlink" title="常用方法"></a>常用方法</h2><ul>
<li><p>public int size()</p>
</li>
<li><p>public boolean isEmpty()</p>
</li>
<li><p>public V get(Object key)</p>
</li>
<li><p>public boolean containsKey(Object key)</p>
</li>
<li><p>public V put(K key, V value)</p>
</li>
<li><p>public void putAll(Map&lt;? extends K, ? extends V&gt; m)</p>
</li>
<li><p>public V remove(Object key) </p>
</li>
<li><p>public void clear()</p>
</li>
<li><p>public boolean containsValue(Object value)</p>
</li>
<li><p>public Set<k> keySet()<br>获取存储的所有键值对的键的Set对象，因为键是没有重复的，因此返回一个Set对象，而不是List</k></p>
</li>
<li><p>public Collection<v> values()<br>获取存储的所有键值对的值的Collection对象，因为值可以是可以重复的任意对象，因此返回一个Collection对象</v></p>
</li>
<li><p>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()<br>获取存储的所有键值对，键值对被封装进一个Set对象后返回</p>
</li>
<li><p>public V getOrDefault(Object key, V defaultValue)<br>获取某个key的值，如果key不存在则返回默认值（defaultValue）</p>
</li>
<li><p>public V putIfAbsent(K key, V value)<br>当要存放的键值对的键不存在于Map中时才将键值对存放进Map中</p>
</li>
<li><p>public boolean remove(Object key, Object value)<br>当指定的值和要移除的键值对的值相匹配时才移除该键值对</p>
</li>
<li><p>public boolean replace(K key, V oldValue, V newValue)</p>
</li>
<li><p>public V replace(K key, V value) </p>
</li>
</ul>
<h1 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h1><p><code>LinkedHashMap</code>继承了<code>HashMap</code>并且实现了<code>Map</code>接口，它的迭代顺序是可预测的（通过它的iterator方法得到的迭代器迭代对象的时候是按照元素插入的时间顺序进行迭代的）。<br>它一般用来复制Map对象，并能保证复制后的对象的元素顺序和复制前的对象一致。</p>
<h2 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty insertion-ordered &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance</span></span><br><span class="line"><span class="comment"> * with the specified initial capacity and load factor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment"> *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty insertion-ordered &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance</span></span><br><span class="line"><span class="comment"> * with the specified initial capacity and a default load factor (0.75).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity);</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty insertion-ordered &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance</span></span><br><span class="line"><span class="comment"> * with the default initial capacity (16) and load factor (0.75).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an insertion-ordered &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance with</span></span><br><span class="line"><span class="comment"> * the same mappings as the specified map.  The &lt;tt&gt;LinkedHashMap&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * instance is created with a default load factor (0.75) and an initial</span></span><br><span class="line"><span class="comment"> * capacity sufficient to hold the mappings in the specified map.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  m the map whose mappings are to be placed in this map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance with the</span></span><br><span class="line"><span class="comment"> * specified initial capacity, load factor and ordering mode.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  accessOrder     the ordering mode - &lt;tt&gt;true&lt;/tt&gt; for</span></span><br><span class="line"><span class="comment"> *         access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment"> *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">float</span> loadFactor,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常用方法-5"><a href="#常用方法-5" class="headerlink" title="常用方法"></a>常用方法</h2><p>和HashMap一致</p>
<h1 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h1><p><code>Hashtable</code>功能和HashMap差不多，但Hashtable是线程安全的。Hashtable的实现也在<a href="https://plentymore.github.io/2018/08/15/Hashtable/">这里</a>介绍过了。<br>它不能存放null键值对。</p>
<h2 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty hashtable with the specified initial</span></span><br><span class="line"><span class="comment"> * capacity and the specified load factor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      initialCapacity   the initial capacity of the hashtable.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      loadFactor        the load factor of the hashtable.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span>  IllegalArgumentException  if the initial capacity is less</span></span><br><span class="line"><span class="comment"> *             than zero, or if the load factor is nonpositive.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Load: "</span>+loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity==<span class="number">0</span>)</span><br><span class="line">        initialCapacity = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    table = <span class="keyword">new</span> Entry&lt;?,?&gt;[initialCapacity];</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty hashtable with the specified initial capacity</span></span><br><span class="line"><span class="comment"> * and default load factor (0.75).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>     initialCapacity   the initial capacity of the hashtable.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span> IllegalArgumentException if the initial capacity is less</span></span><br><span class="line"><span class="comment"> *              than zero.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="number">0.75f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty hashtable with a default initial capacity (11)</span></span><br><span class="line"><span class="comment"> * and load factor (0.75).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">11</span>, <span class="number">0.75f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new hashtable with the same mappings as the given</span></span><br><span class="line"><span class="comment"> * Map.  The hashtable is created with an initial capacity sufficient to</span></span><br><span class="line"><span class="comment"> * hold the mappings in the given Map and a default load factor (0.75).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> t the map whose mappings are to be placed in this map.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified map is null.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(Map&lt;? extends K, ? extends V&gt; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Math.max(<span class="number">2</span>*t.size(), <span class="number">11</span>), <span class="number">0.75f</span>);</span><br><span class="line">    putAll(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常用方法-6"><a href="#常用方法-6" class="headerlink" title="常用方法"></a>常用方法</h2><ul>
<li><p>public synchronized int size()</p>
</li>
<li><p>public synchronized boolean isEmpty()</p>
</li>
<li><p>public synchronized Enumeration<k> keys()<br>获取存储的所有键值对的键，封装成Enumeration类型后返回</k></p>
</li>
<li><p>public synchronized Enumeration<v> elements()<br>获取存储的所有键值对的值，封装成Enumeration类型后返回</v></p>
</li>
<li><p>public synchronized boolean contains(Object value)</p>
</li>
<li><p>public boolean containsValue(Object value)</p>
</li>
<li><p>public synchronized boolean containsKey(Object key)</p>
</li>
<li><p>public synchronized V get(Object key)</p>
</li>
<li><p>public synchronized V put(K key, V value)</p>
</li>
<li><p>public synchronized V remove(Object key)</p>
</li>
<li><p>public synchronized boolean remove(Object key, Object value)<br>当key和value都与Map里面对象的元素匹配时才移除元素</p>
</li>
<li><p>public synchronized void putAll(Map&lt;? extends K, ? extends V&gt; t)</p>
</li>
<li><p>public synchronized void clear()</p>
</li>
<li><p>public Set<k> keySet() </k></p>
</li>
<li><p>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</p>
</li>
<li><p>public Collection<v> values()</v></p>
</li>
<li><p>public synchronized V getOrDefault(Object key, V defaultValue) </p>
</li>
<li><p>public synchronized V putIfAbsent(K key, V value)</p>
</li>
<li><p>public synchronized boolean replace(K key, V oldValue, V newValue) </p>
</li>
<li><p>public synchronized V replace(K key, V value) </p>
</li>
</ul>
<h1 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h1><p><code>TreeMap</code>是以红黑色为底层结构的Map借口实现类，功能和其他的Map实现了基本一致。该类不是线程安全的，<br>要在多线程中使用它需要使用外部同步。它不能存放为null的键，但可以存放为null的值</p>
<p>This implementation provides guaranteed log(n) time cost for the<br> {@code containsKey}, {@code get}, {@code put} and {@code remove}<br> operations</p>
<p> <code>containsKey</code>， <code>get</code>，<code>put</code>，<code>remove</code>等方法的时间复杂度是O(log(n))。该类存储的元素是有序的，<br> 一般通过自然顺序进行排序，如果在构造函数中提供了自定义的Comparator，则按照自定义的Comparator进行排序。</p>
<h2 id="成员变量-4"><a href="#成员变量-4" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The comparator used to maintain order in this tree map, or</span></span><br><span class="line"><span class="comment"> * null if it uses the natural ordering of its keys.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of entries in the tree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of structural modifications to the tree.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h2 id="构造函数-2"><a href="#构造函数-2" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty tree map, using the natural ordering of its</span></span><br><span class="line"><span class="comment"> * keys.  All keys inserted into the map must implement the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * Comparable&#125; interface.  Furthermore, all such keys must be</span></span><br><span class="line"><span class="comment"> * &lt;em&gt;mutually comparable&lt;/em&gt;: &#123;<span class="doctag">@code</span> k1.compareTo(k2)&#125; must not throw</span></span><br><span class="line"><span class="comment"> * a &#123;<span class="doctag">@code</span> ClassCastException&#125; for any keys &#123;<span class="doctag">@code</span> k1&#125; and</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> k2&#125; in the map.  If the user attempts to put a key into the</span></span><br><span class="line"><span class="comment"> * map that violates this constraint (for example, the user attempts to</span></span><br><span class="line"><span class="comment"> * put a string key into a map whose keys are integers), the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> put(Object key, Object value)&#125; call will throw a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> ClassCastException&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    comparator = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty tree map, ordered according to the given</span></span><br><span class="line"><span class="comment"> * comparator.  All keys inserted into the map must be &lt;em&gt;mutually</span></span><br><span class="line"><span class="comment"> * comparable&lt;/em&gt; by the given comparator: &#123;<span class="doctag">@code</span> comparator.compare(k1,</span></span><br><span class="line"><span class="comment"> * k2)&#125; must not throw a &#123;<span class="doctag">@code</span> ClassCastException&#125; for any keys</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> k1&#125; and &#123;<span class="doctag">@code</span> k2&#125; in the map.  If the user attempts to put</span></span><br><span class="line"><span class="comment"> * a key into the map that violates this constraint, the &#123;<span class="doctag">@code</span> put(Object</span></span><br><span class="line"><span class="comment"> * key, Object value)&#125; call will throw a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> ClassCastException&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> comparator the comparator that will be used to order this map.</span></span><br><span class="line"><span class="comment"> *        If &#123;<span class="doctag">@code</span> null&#125;, the &#123;<span class="doctag">@linkplain</span> Comparable natural</span></span><br><span class="line"><span class="comment"> *        ordering&#125; of the keys will be used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> K&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new tree map containing the same mappings as the given</span></span><br><span class="line"><span class="comment"> * map, ordered according to the &lt;em&gt;natural ordering&lt;/em&gt; of its keys.</span></span><br><span class="line"><span class="comment"> * All keys inserted into the new map must implement the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * Comparable&#125; interface.  Furthermore, all such keys must be</span></span><br><span class="line"><span class="comment"> * &lt;em&gt;mutually comparable&lt;/em&gt;: &#123;<span class="doctag">@code</span> k1.compareTo(k2)&#125; must not throw</span></span><br><span class="line"><span class="comment"> * a &#123;<span class="doctag">@code</span> ClassCastException&#125; for any keys &#123;<span class="doctag">@code</span> k1&#125; and</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> k2&#125; in the map.  This method runs in n*log(n) time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  m the map whose mappings are to be placed in this map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException if the keys in m are not &#123;<span class="doctag">@link</span> Comparable&#125;,</span></span><br><span class="line"><span class="comment"> *         or are not mutually comparable</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    comparator = <span class="keyword">null</span>;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new tree map containing the same mappings and</span></span><br><span class="line"><span class="comment"> * using the same ordering as the specified sorted map.  This</span></span><br><span class="line"><span class="comment"> * method runs in linear time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  m the sorted map whose mappings are to be placed in this map,</span></span><br><span class="line"><span class="comment"> *         and whose comparator is to be used to sort this map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(SortedMap&lt;K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    comparator = m.comparator();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        buildFromSorted(m.size(), m.entrySet().iterator(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.io.IOException cannotHappen) &#123;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException cannotHappen) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常用方法-7"><a href="#常用方法-7" class="headerlink" title="常用方法"></a>常用方法</h2><ul>
<li><p>public int size()</p>
</li>
<li><p>public boolean containsKey(Object key)</p>
</li>
<li><p>public boolean containsValue(Object value) </p>
</li>
<li><p>public V get(Object key) </p>
</li>
<li><p>public Comparator&lt;? super K&gt; comparator()<br>获取自定义的Comparator</p>
</li>
<li><p>public K firstKey()</p>
</li>
<li><p>public K lastKey()</p>
</li>
<li><p>public void putAll(Map&lt;? extends K, ? extends V&gt; map)</p>
</li>
<li><p>public V put(K key, V value) </p>
</li>
<li><p>public V remove(Object key)</p>
</li>
<li><p>public void clear()</p>
</li>
<li><p>public Map.Entry&lt;K,V&gt; firstEntry()<br>获取第一个键值对的Entry对象</p>
</li>
<li><p>public Map.Entry&lt;K,V&gt; lastEntry()<br>获取最后一个键值对的Entry对象</p>
</li>
<li><p>public Map.Entry&lt;K,V&gt; pollFirstEntry()<br>移除并返回Map中最前面的一个元素</p>
</li>
<li><p>public Map.Entry&lt;K,V&gt; pollLastEntry()<br>移除并返回Map中最后面的一个元素</p>
</li>
<li><p>public Map.Entry&lt;K,V&gt; lowerEntry(K key)<br>返回key小于指定key的键值对，返回的键值对的键同时也是Map中的最大的键</p>
</li>
<li><p>public K lowerKey(K key)<br>返回key小于指定key的键，返回的键同时也是Map中的最大的键</p>
</li>
<li><p>public Map.Entry&lt;K,V&gt; floorEntry(K key)<br>返回key小于或等于指定key的键值对，返回的键值对的键同时也是Map中的最大的键</p>
</li>
<li><p>public K floorKey(K key)<br>返回key小于等于指定key的键，返回的键同时也是Map中的最大的键</p>
</li>
<li><p>public Map.Entry&lt;K,V&gt; ceilingEntry(K key)<br>返回key大于或等于指定key的键值对，返回的键值对的键同时也是Map中的最小的键</p>
</li>
<li><p>public K ceilingKey(K key)<br>返回key大于等于指定key的键，返回的键同时也是Map中的最小的键</p>
</li>
<li><p>public Map.Entry&lt;K,V&gt; higherEntry(K key)<br>返回key大于指定key的键值对，返回的键值对的键同时也是Map中的最小的键</p>
</li>
<li><p>public K higherKey(K key)<br>返回key大于指定key的键，返回的键同时也是Map中的最小的键</p>
</li>
<li><p>public Set<k> keySet()</k></p>
</li>
<li><p>public NavigableSet<k> navigableKeySet()<br>返回Map中的所有key，key按照原本的顺序排列，封装成NavigableSet类型后返回</k></p>
</li>
<li><p>public NavigableSet<k> descendingKeySet()<br>返回Map中的所有key，key按照降序排列，封装成NavigableSet类型后返回</k></p>
</li>
<li><p>public Collection<v> values()<br>返回Map中的所有值，值按照升序排列，封装成Collection类型后返回</v></p>
</li>
<li><p>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()<br>返回Map中的所有键值对，按照升序排列，封装成Set类型后返回</p>
</li>
<li><p>public NavigableMap&lt;K, V&gt; descendingMap()<br>返回Map中所有键值对，按照倒叙排列，封装成NavigableMap类型后返回</p>
</li>
<li><p>public boolean replace(K key, V oldValue, V newValue)<br>当指定的key和oldValue和Map中的key-value都对应时替换oldValue为newValue</p>
</li>
<li><p>public V replace(K key, V value)<br>替换指定key的value</p>
</li>
</ul>
<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><p>这是线程安全版的<code>HashMap</code>，主要在并发环境下使用，它是线程安全的。它的实现比<code>HashMap</code>要复杂很多，<br>由于使用了CAS来实现同步，在并发环境它的性能要比Hashtable高很多，因此在并发环境下建议使用<code>ConcurrentHashMap</code>，<br>它不允许存放null键值对。</p>
<h2 id="成员变量-5"><a href="#成员变量-5" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ---------------- Constants -------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The largest possible table capacity.  This value must be</span></span><br><span class="line"><span class="comment"> * exactly 1&lt;&lt;30 to stay within Java array allocation and indexing</span></span><br><span class="line"><span class="comment"> * bounds for power of two table sizes, and is further required</span></span><br><span class="line"><span class="comment"> * because the top two bits of 32bit hash fields are used for</span></span><br><span class="line"><span class="comment"> * control purposes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default initial table capacity.  Must be a power of 2</span></span><br><span class="line"><span class="comment"> * (i.e., at least 1) and at most MAXIMUM_CAPACITY.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The largest possible (non-power of two) array size.</span></span><br><span class="line"><span class="comment"> * Needed by toArray and related methods.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default concurrency level for this table. Unused but</span></span><br><span class="line"><span class="comment"> * defined for compatibility with previous versions of this class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor for this table. Overrides of this value in</span></span><br><span class="line"><span class="comment"> * constructors affect only the initial table capacity.  The</span></span><br><span class="line"><span class="comment"> * actual floating point value isn't normally used -- it is</span></span><br><span class="line"><span class="comment"> * simpler to use expressions such as &#123;<span class="doctag">@code</span> n - (n &gt;&gt;&gt; 2)&#125; for</span></span><br><span class="line"><span class="comment"> * the associated resizing threshold.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bin count threshold for using a tree rather than list for a</span></span><br><span class="line"><span class="comment"> * bin.  Bins are converted to trees when adding an element to a</span></span><br><span class="line"><span class="comment"> * bin with at least this many nodes. The value must be greater</span></span><br><span class="line"><span class="comment"> * than 2, and should be at least 8 to mesh with assumptions in</span></span><br><span class="line"><span class="comment"> * tree removal about conversion back to plain bins upon</span></span><br><span class="line"><span class="comment"> * shrinkage.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bin count threshold for untreeifying a (split) bin during a</span></span><br><span class="line"><span class="comment"> * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span></span><br><span class="line"><span class="comment"> * most 6 to mesh with shrinkage detection under removal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The smallest table capacity for which bins may be treeified.</span></span><br><span class="line"><span class="comment"> * (Otherwise the table is resized if too many nodes in a bin.)</span></span><br><span class="line"><span class="comment"> * The value should be at least 4 * TREEIFY_THRESHOLD to avoid</span></span><br><span class="line"><span class="comment"> * conflicts between resizing and treeification thresholds.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Minimum number of rebinnings per transfer step. Ranges are</span></span><br><span class="line"><span class="comment"> * subdivided to allow multiple resizer threads.  This value</span></span><br><span class="line"><span class="comment"> * serves as a lower bound to avoid resizers encountering</span></span><br><span class="line"><span class="comment"> * excessive memory contention.  The value should be at least</span></span><br><span class="line"><span class="comment"> * DEFAULT_CAPACITY.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of bits used for generation stamp in sizeCtl.</span></span><br><span class="line"><span class="comment"> * Must be at least 6 for 32bit arrays.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The maximum number of threads that can help resize.</span></span><br><span class="line"><span class="comment"> * Must fit in 32 - RESIZE_STAMP_BITS bits.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bit shift for recording size stamp in sizeCtl.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Encodings for Node hash fields. See above for explanation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// hash for forwarding nodes</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// hash for roots of trees</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; <span class="comment">// hash for transient reservations</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Number of CPUS, to place bounds on some sizings */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** For serialization compatibility. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectStreamField[] serialPersistentFields = &#123;</span><br><span class="line">    <span class="keyword">new</span> ObjectStreamField(<span class="string">"segments"</span>, Segment[].class),</span><br><span class="line">    <span class="keyword">new</span> ObjectStreamField(<span class="string">"segmentMask"</span>, Integer.TYPE),</span><br><span class="line">    <span class="keyword">new</span> ObjectStreamField(<span class="string">"segmentShift"</span>, Integer.TYPE)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ---------------- Fields -------------- */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The array of bins. Lazily initialized upon first insertion.</span></span><br><span class="line"><span class="comment">     * Size is always a power of two. Accessed directly by iterators.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The next table to use; non-null only while resizing.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Base counter value, used mainly when there is no contention,</span></span><br><span class="line"><span class="comment">     * but also as a fallback during table initialization</span></span><br><span class="line"><span class="comment">     * races. Updated via CAS.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Table initialization and resizing control.  When negative, the</span></span><br><span class="line"><span class="comment">     * table is being initialized or resized: -1 for initialization,</span></span><br><span class="line"><span class="comment">     * else -(1 + the number of active resizing threads).  Otherwise,</span></span><br><span class="line"><span class="comment">     * when table is null, holds the initial table size to use upon</span></span><br><span class="line"><span class="comment">     * creation, or 0 for default. After initialization, holds the</span></span><br><span class="line"><span class="comment">     * next element count value upon which to resize the table.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The next table index (plus one) to split while resizing.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> transferIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spinlock (locked via CAS) used when resizing and/or creating CounterCells.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Table of counter cells. When non-null, size is a power of 2.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// views</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> KeySetView&lt;K,V&gt; keySet;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ValuesView&lt;K,V&gt; values;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> EntrySetView&lt;K,V&gt; entrySet;</span><br></pre></td></tr></table></figure>
<h2 id="构造函数-3"><a href="#构造函数-3" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new, empty map with the default initial table size (16).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new, empty map with an initial table size</span></span><br><span class="line"><span class="comment"> * accommodating the specified number of elements without the need</span></span><br><span class="line"><span class="comment"> * to dynamically resize.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity The implementation performs internal</span></span><br><span class="line"><span class="comment"> * sizing to accommodate this many elements.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity of</span></span><br><span class="line"><span class="comment"> * elements is negative</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new map with the same mappings as the given map.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m the map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new, empty map with an initial table size based on</span></span><br><span class="line"><span class="comment"> * the given number of elements (&#123;<span class="doctag">@code</span> initialCapacity&#125;) and</span></span><br><span class="line"><span class="comment"> * initial table density (&#123;<span class="doctag">@code</span> loadFactor&#125;).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity the initial capacity. The implementation</span></span><br><span class="line"><span class="comment"> * performs internal sizing to accommodate this many elements,</span></span><br><span class="line"><span class="comment"> * given the specified load factor.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loadFactor the load factor (table density) for</span></span><br><span class="line"><span class="comment"> * establishing the initial table size</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity of</span></span><br><span class="line"><span class="comment"> * elements is negative or the load factor is nonpositive</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, loadFactor, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new, empty map with an initial table size based on</span></span><br><span class="line"><span class="comment"> * the given number of elements (&#123;<span class="doctag">@code</span> initialCapacity&#125;), table</span></span><br><span class="line"><span class="comment"> * density (&#123;<span class="doctag">@code</span> loadFactor&#125;), and number of concurrently</span></span><br><span class="line"><span class="comment"> * updating threads (&#123;<span class="doctag">@code</span> concurrencyLevel&#125;).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity the initial capacity. The implementation</span></span><br><span class="line"><span class="comment"> * performs internal sizing to accommodate this many elements,</span></span><br><span class="line"><span class="comment"> * given the specified load factor.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loadFactor the load factor (table density) for</span></span><br><span class="line"><span class="comment"> * establishing the initial table size</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> concurrencyLevel the estimated number of concurrently</span></span><br><span class="line"><span class="comment"> * updating threads. The implementation may use this value as</span></span><br><span class="line"><span class="comment"> * a sizing hint.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is</span></span><br><span class="line"><span class="comment"> * negative or the load factor or concurrencyLevel are</span></span><br><span class="line"><span class="comment"> * nonpositive</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">        initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">    <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size);</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常用方法-8"><a href="#常用方法-8" class="headerlink" title="常用方法"></a>常用方法</h2><p>常用方法和Hashtable一样</p>
<h1 id="IdentityHashMap"><a href="#IdentityHashMap" class="headerlink" title="IdentityHashMap"></a>IdentityHashMap</h1><p><code>IdentityHashMap</code>是一种特殊的Map，它的特别之处在于，在判断两个key是否相等的时候，<br>只有当key1 == key2的时候（使用<code>==</code>操作符）才认为这两个key是相等的，因此它的判断方式是判断引用相等，而不是对象相等。<br>该类的详细用途可以查看<a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="noopener">文档</a></p>
<h1 id="Map总结"><a href="#Map总结" class="headerlink" title="Map总结"></a>Map总结</h1><ul>
<li><code>ConcurrentHashMap</code>和<code>Hashtable</code>是线程安全的，其它的不是</li>
<li><code>ConcurrentHashMap</code>和<code>Hashtable</code>不允许存放null键值对，<code>HashMap</code>可以，<code>TreeMap</code>可以不可存放null键，可以存放null值</li>
<li><code>TreeMap</code>是有序（按照自然顺序或者用户自定义排序规则排序）的，其他的一般是无序的（如返回的<code>Iterator</code>不保证迭代元素顺序一致）</li>
<li><code>HashMap</code>和<code>ConcurrentHashMap</code>在JDK1.8开始，在Hash冲突严重的时候会将链表结构转换成红黑树结构，因此它们的查找操作的最坏时间复杂度为O(log(n))</li>
</ul>
<h1 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h1><p><code>HashSet</code>是<code>Set</code>接口的一种Hash实现，和<code>List</code>接口不同，<code>Set</code>接口不包含重复的元素。<br><code>HashSet</code>不保证迭代顺序，它不是线程安全的，允许添加null元素</p>
<h2 id="成员变量-6"><a href="#成员变量-6" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>
<h2 id="构造方法-5"><a href="#构造方法-5" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span></span><br><span class="line"><span class="comment"> * default initial capacity (16) and load factor (0.75).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new set containing the elements in the specified</span></span><br><span class="line"><span class="comment"> * collection.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with default load factor</span></span><br><span class="line"><span class="comment"> * (0.75) and an initial capacity sufficient to contain the elements in</span></span><br><span class="line"><span class="comment"> * the specified collection.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c the collection whose elements are to be placed into this set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span></span><br><span class="line"><span class="comment"> * the specified initial capacity and the specified load factor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      initialCapacity   the initial capacity of the hash map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      loadFactor        the load factor of the hash map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>     IllegalArgumentException if the initial capacity is less</span></span><br><span class="line"><span class="comment"> *             than zero, or if the load factor is nonpositive</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span></span><br><span class="line"><span class="comment"> * the specified initial capacity and default load factor (0.75).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      initialCapacity   the initial capacity of the hash table</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>     IllegalArgumentException if the initial capacity is less</span></span><br><span class="line"><span class="comment"> *             than zero</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty linked hash set.  (This package private</span></span><br><span class="line"><span class="comment"> * constructor is only used by LinkedHashSet.) The backing</span></span><br><span class="line"><span class="comment"> * HashMap instance is a LinkedHashMap with the specified initial</span></span><br><span class="line"><span class="comment"> * capacity and the specified load factor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      initialCapacity   the initial capacity of the hash map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      loadFactor        the load factor of the hash map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      dummy             ignored (distinguishes this</span></span><br><span class="line"><span class="comment"> *             constructor from other int, float constructor.)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>     IllegalArgumentException if the initial capacity is less</span></span><br><span class="line"><span class="comment"> *             than zero, or if the load factor is nonpositive</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常用方法-9"><a href="#常用方法-9" class="headerlink" title="常用方法"></a>常用方法</h2><ul>
<li><p>public int size()</p>
</li>
<li><p>public boolean isEmpty()</p>
</li>
<li><p>public boolean contains(Object o)</p>
</li>
<li><p>public boolean add(E e)<br>添加一个元素到Set，如果该元素已经存在，则不添加</p>
</li>
<li><p>public boolean remove(Object o)</p>
</li>
<li><p>public void clear()</p>
</li>
</ul>
<h1 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h1><p><code>NavigableSet</code>的一种实现，它的实现基于<code>TreeMap</code>，其实就是没有值的<code>TreeMap</code>，<br>它的元素是有序（按照自然顺序或者用户自定义的排序规则排序）的。<br>  </p><p>This implementation provides guaranteed log(n) time cost for the basic<br>  operations ({@code add}, {@code remove} and {@code contains}).</p>
<p><code>add</code>，<code>remove</code>，<code>contains</code>等基本操作的时间复杂度均为log(n)，它不是线程安全的。</p>
<h2 id="成员变量-7"><a href="#成员变量-7" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The backing map.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>
<h2 id="构造函数-4"><a href="#构造函数-4" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a set backed by the specified navigable map.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TreeSet(NavigableMap&lt;E,Object&gt; m) &#123;</span><br><span class="line">    <span class="keyword">this</span>.m = m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty tree set, sorted according to the</span></span><br><span class="line"><span class="comment"> * natural ordering of its elements.  All elements inserted into</span></span><br><span class="line"><span class="comment"> * the set must implement the &#123;<span class="doctag">@link</span> Comparable&#125; interface.</span></span><br><span class="line"><span class="comment"> * Furthermore, all such elements must be &lt;i&gt;mutually</span></span><br><span class="line"><span class="comment"> * comparable&lt;/i&gt;: &#123;<span class="doctag">@code</span> e1.compareTo(e2)&#125; must not throw a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> ClassCastException&#125; for any elements &#123;<span class="doctag">@code</span> e1&#125; and</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> e2&#125; in the set.  If the user attempts to add an element</span></span><br><span class="line"><span class="comment"> * to the set that violates this constraint (for example, the user</span></span><br><span class="line"><span class="comment"> * attempts to add a string element to a set whose elements are</span></span><br><span class="line"><span class="comment"> * integers), the &#123;<span class="doctag">@code</span> add&#125; call will throw a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> ClassCastException&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;E,Object&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty tree set, sorted according to the specified</span></span><br><span class="line"><span class="comment"> * comparator.  All elements inserted into the set must be &lt;i&gt;mutually</span></span><br><span class="line"><span class="comment"> * comparable&lt;/i&gt; by the specified comparator: &#123;<span class="doctag">@code</span> comparator.compare(e1,</span></span><br><span class="line"><span class="comment"> * e2)&#125; must not throw a &#123;<span class="doctag">@code</span> ClassCastException&#125; for any elements</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> e1&#125; and &#123;<span class="doctag">@code</span> e2&#125; in the set.  If the user attempts to add</span></span><br><span class="line"><span class="comment"> * an element to the set that violates this constraint, the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> add&#125; call will throw a &#123;<span class="doctag">@code</span> ClassCastException&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> comparator the comparator that will be used to order this set.</span></span><br><span class="line"><span class="comment"> *        If &#123;<span class="doctag">@code</span> null&#125;, the &#123;<span class="doctag">@linkplain</span> Comparable natural</span></span><br><span class="line"><span class="comment"> *        ordering&#125; of the elements will be used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;&gt;(comparator));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new tree set containing the elements in the specified</span></span><br><span class="line"><span class="comment"> * collection, sorted according to the &lt;i&gt;natural ordering&lt;/i&gt; of its</span></span><br><span class="line"><span class="comment"> * elements.  All elements inserted into the set must implement the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Comparable&#125; interface.  Furthermore, all such elements must be</span></span><br><span class="line"><span class="comment"> * &lt;i&gt;mutually comparable&lt;/i&gt;: &#123;<span class="doctag">@code</span> e1.compareTo(e2)&#125; must not throw a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> ClassCastException&#125; for any elements &#123;<span class="doctag">@code</span> e1&#125; and</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> e2&#125; in the set.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c collection whose elements will comprise the new set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException if the elements in &#123;<span class="doctag">@code</span> c&#125; are</span></span><br><span class="line"><span class="comment"> *         not &#123;<span class="doctag">@link</span> Comparable&#125;, or are not mutually comparable</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new tree set containing the same elements and</span></span><br><span class="line"><span class="comment"> * using the same ordering as the specified sorted set.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s sorted set whose elements will comprise the new set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified sorted set is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(SortedSet&lt;E&gt; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(s.comparator());</span><br><span class="line">    addAll(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常用方法-10"><a href="#常用方法-10" class="headerlink" title="常用方法"></a>常用方法</h2><ul>
<li><p>public Iterator<e> iterator()</e></p>
</li>
<li><p>public Iterator<e> descendingIterator()</e></p>
</li>
<li><p>public NavigableSet<e> descendingSet()</e></p>
</li>
<li><p>public int size()</p>
</li>
<li><p>public boolean isEmpty()</p>
</li>
<li><p>public boolean contains(Object o)</p>
</li>
<li><p>public boolean add(E e)</p>
</li>
<li><p>public boolean remove(Object o)</p>
</li>
<li><p>public void clear()</p>
</li>
</ul>
<h1 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h1><p><code>LinkedHashSet</code>的迭代是有序的（通过它的iterator方法得到的迭代器迭代元素的顺序和插入元素的时间顺序一致），<br>它继承了<code>HashMap</code>类并实现了<code>Set</code>接口，一般用来复制一个Set对象，并且要保持复制后的元素顺序和原来的Set对象一致，比如：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(Set s)</span> </span>&#123;</span><br><span class="line">    Set copy = <span class="keyword">new</span> LinkedHashSet(s);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="成员变量-8"><a href="#成员变量-8" class="headerlink" title="成员变量"></a>成员变量</h2><p>没有自己的成员变量</p>
<h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><pre><code class="java">
<span class="comment">/**</span>
<span class="comment"> * Constructs a new, empty linked hash set with the specified initial</span>
<span class="comment"> * capacity and load factor.</span>
<span class="comment"> *</span>
<span class="comment"> * <span class="doctag">@param</span>      initialCapacity the initial capacity of the linked hash set</span>
<span class="comment"> * <span class="doctag">@param</span>      loadFactor      the load factor of the linked hash set</span>
<span class="comment"> * <span class="doctag">@throws</span>     IllegalArgumentException  if the initial capacity is less</span>
<span class="comment"> *               than zero, or if the load factor is nonpositive</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>{
    <span class="keyword">super</span>(initialCapacity, loadFactor, <span class="keyword">true</span>);
}

<span class="comment">/**</span>
<span class="comment"> * Constructs a new, empty linked hash set with the specified initial</span>
<span class="comment"> * capacity and the default load factor (0.75).</span>
<span class="comment"> *</span>
<span class="comment"> * <span class="doctag">@param</span>   initialCapacity   the initial capacity of the LinkedHashSet</span>
<span class="comment"> * <span class="doctag">@throws</span>  IllegalArgumentException if the initial capacity is less</span>
<span class="comment"> *              than zero</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>{
    <span class="keyword">super</span>(initialCapacity, .<span class="number">75f</span>, <span class="keyword">true</span>);
}

<span class="comment">/**</span>
<span class="comment"> * Constructs a new, empty linked hash set with the default initial</span>
<span class="comment"> * capacity (16) and load factor (0.75).</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">()</span> </span>{
    <span class="keyword">super</span>(<span class="number">16</span>, .<span class="number">75f</span>, <span class="keyword">true</span>);
}

<span class="comment">/**</span>
<span class="comment"> * Constructs a new linked hash set with the same elements as the</span>
<span class="comment"> * specified collection.  The linked hash set is created with an initial</span>
<span class="comment"> * capacity sufficient to hold the elements in the specified collection</span>
<span class="comment"> * and the default load factor (0.75).</span>
<span class="comment"> *</span>
<span class="comment"> * <span class="doctag">@param</span> c  the collection whose elements are to be placed into</span>
<span class="comment"> *           this set</span>
<span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>{
    <span class="keyword">super</span>(Math.max(<span class="number">2</span>*c.size(), <span class="number">11</span>), .<span class="number">75f</span>, <span class="keyword">true</span>);
    addAll(c);
}
</code></pre>
<h2 id="常用方法-11"><a href="#常用方法-11" class="headerlink" title="常用方法"></a>常用方法</h2><p>继承了HashSet的方法</p>
<h1 id="Set总结"><a href="#Set总结" class="headerlink" title="Set总结"></a>Set总结</h1><ul>
<li><code>Set</code>不包含重复元素</li>
<li><code>HashSet</code>是无序的(迭代元素的时候不会按照插入元素的顺序进行迭代)，<code>TreeSet</code>和<code>LinkedHashSet</code>是有序的</li>
</ul>

                <hr>
                

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2018/09/12/Collection-Framework-2/" data-toggle="tooltip" data-placement="top"
                           title="Collection-Framework(2)">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2018/08/18/Red-Black-Tree/" data-toggle="tooltip" data-placement="top"
                           title="Red-Black Tree">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                

                


                <!--加入新的评论系统-->
                
                <!-- 来必力City版安装代码 -->
                <div id="lv-container" data-id="city" data-uid="MTAyMC8zODUyNi8xNTA1NA==">
                    <script type="text/javascript">
                        (function(d, s) {
                            var j, e = d.getElementsByTagName(s)[0];

                            if (typeof LivereTower === 'function') { return; }

                            j = d.createElement(s);
                            j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                            j.async = true;

                            e.parentNode.insertBefore(j, e);
                        })(document, 'script');
                    </script>
                    <noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
                </div>
                <!-- City版安装代码已完成 -->
                
            </div>

            <div class="hidden-xs col-sm-3 toc-col">
                <div class="toc-wrap">
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#ArrayList"><span class="toc-text">ArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#fail-fast"><span class="toc-text">fail-fast</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#成员变量"><span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造方法"><span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常用方法"><span class="toc-text">常用方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vector"><span class="toc-text">Vector</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#成员变量-1"><span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造函数"><span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常用方法-1"><span class="toc-text">常用方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LinkedList"><span class="toc-text">LinkedList</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#成员变量-2"><span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造方法-1"><span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常用方法-2"><span class="toc-text">常用方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CopyOnWriteArrayList"><span class="toc-text">CopyOnWriteArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#成员变量-3"><span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造方法-2"><span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常用方法-3"><span class="toc-text">常用方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#List总结"><span class="toc-text">List总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HashMap"><span class="toc-text">HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#构造函数-1"><span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常用方法-4"><span class="toc-text">常用方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LinkedHashMap"><span class="toc-text">LinkedHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#构造方法-3"><span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常用方法-5"><span class="toc-text">常用方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hashtable"><span class="toc-text">Hashtable</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#构造方法-4"><span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常用方法-6"><span class="toc-text">常用方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TreeMap"><span class="toc-text">TreeMap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#成员变量-4"><span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造函数-2"><span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常用方法-7"><span class="toc-text">常用方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-text">ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#成员变量-5"><span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造函数-3"><span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常用方法-8"><span class="toc-text">常用方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IdentityHashMap"><span class="toc-text">IdentityHashMap</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Map总结"><span class="toc-text">Map总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HashSet"><span class="toc-text">HashSet</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#成员变量-6"><span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造方法-5"><span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常用方法-9"><span class="toc-text">常用方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TreeSet"><span class="toc-text">TreeSet</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#成员变量-7"><span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造函数-4"><span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常用方法-10"><span class="toc-text">常用方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LinkedHashSet"><span class="toc-text">LinkedHashSet</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#成员变量-8"><span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造器"><span class="toc-text">构造器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常用方法-11"><span class="toc-text">常用方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Set总结"><span class="toc-text">Set总结</span></a></li></ol>
                </div>
            </div>
        </div>

        <div class="row">
            <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5 class="text-center">
                        <a href="/Tags/">FEATURED TAGS</a>
                    </h5>
                    <div class="tags">
                        
                        <a class="tag" href="/Tags/#Container"
                           title="Container">Container</a>
                        
                        <a class="tag" href="/Tags/#Collection"
                           title="Collection">Collection</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <div style="margin-top: 20px;">
                    <h5 class="text-center">FRIENDS</h5>
                    <ul class="list-inline text-center">
                        
                        <li><a href="https://echi.me">echisan</a></li>
                        
                    </ul>
                </div>
                
            </div>
        </div>

    </div>
</article>







<!-- Footer -->
<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <br>
                <ul class="list-inline text-center">
                
                
                    <li>
                        <a target="_blank" href="https://twitter.com/plentymorea">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/plentymore">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; PLTM 2021
                    <br>
                    <span id="busuanzi_container_site_pv" style="font-size: 12px;">PV: <span id="busuanzi_value_site_pv"></span> Times</span>
                    <br>
                    <br>
                    Theme by <a href="https://github.com/Haojen/hexo-theme-Anisina">Haojen Ma</a>
                </p>

            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/blog.js"></script>

<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://plentymore.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>

<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-123175280-1';
    var _gaDomain = 'plentymore.github.io';
    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>


<!-- Baidu Tongji -->


<!-- swiftype -->
<!-- <script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','','2.0.0');
</script> -->

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<!--wechat title img-->
<img class="wechat-title-img" src="https://avatars3.githubusercontent.com/u/30522768?s=400&amp;u=a2ce54d7c63789391a0ba32b17792b7a21d64fbb&amp;v=4">
</body>

</html>
