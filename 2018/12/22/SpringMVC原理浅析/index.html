<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="BLOG">
    <meta name="keyword" content="pltm">
    <meta name="theme-color" content="#600090">
    <meta name="msapplication-navbutton-color" content="#600090">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="#600090">
    <!-- google-site-verification -->
    <meta name="google-site-verification" content="fgG59EBWTLiWni3UcgCPhkEPiVDNCnLeaocoTWjctOg" />
    <link rel="shortcut icon" href="/images/favicon.png">
    <link rel="alternate" type="application/atom+xml" title="PLTM" href="/atom.xml">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.css">
    <title>
        
        SpringMVC原理浅析｜PTLM blog
        
    </title>

    <link rel="canonical" href="https://plentymore.github.io/2018/12/22/SpringMVC原理浅析/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/blog-style.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">
    <!-- Google AdSense -->
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
             google_ad_client: "ca-pub-1771277850135880",
             enable_page_level_ads: true
          });
    </script>
</head>

<style>

    header.intro-header {
        background-image: url('/images/3.jpg')
    }
</style>
<!-- hack iOS CSS :active style -->
<body ontouchstart="" class="animated fadeIn">
<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top " id="nav-top" data-ispost = "true" data-istags="false
" data-ishome = "false" >
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand animated pulse" href="/">
                <span class="brand-logo">
                    PLTM
                </span>
                's Blog
            </a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <!-- /.navbar-collapse -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
					
                    
                        
							
                        <li>
                            <a href="/Tags/">Tags</a>
                        </li>
							
						
                    
                        
							
								
							
						
                    
					
					
						<li>
							<a href="/about">About</a>
						</li>
					
                </ul>
            </div>
        </div>
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
//    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>

<!-- Main Content -->

<!--only post-->


<img class="wechat-title-img"
     src="/images/3.jpg">


<style>
    
    header.intro-header {
        background-image: url('/images/3.jpg')
    }

    
</style>

<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <div class="post-heading">
                    <h1>SpringMVC原理浅析</h1>
                    
                    <span class="meta">
                         作者 plentymore
                        <span>
                          日期 2018-12-22
                         </span>
                    </span>
                    <div class="tags text-center">
                        
                        <a class="tag" href="/Tags/#SpringMVC"
                           title="SpringMVC">SpringMVC</a>
                        
                        <a class="tag" href="/Tags/#Web"
                           title="Web">Web</a>
                        
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="post-title-haojen">
        <span>
            SpringMVC原理浅析
        </span>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <!-- Post Container -->
            <div class="col-lg-8 col-lg-offset-1 col-sm-9 post-container">
                <p>SpringMVC的原理是把<code>DispatcherServlet</code>作为中央Servlet来处理请求（一般情况下所有请求都会被匹配到DispatcherServlet，因为它的servletMapping一般都是设置为<code>/</code>，而且不会配置其它的有servletMapping的Servlet，jsp Servlet除外），<code>DispatcherServlet</code>根据请求路径找到相应的handler，然后使用HandlerAdapter调用handler进行处理，调用handler之前会先调用拦截器（这里指的是HandlerInterceptor，而不是Filter）的preHandler方法，然后才调用handler，接着解析视图，渲染视图，最后调用拦截器的afterCompletion方法。大概的流程如下图</p>
<p><img src="https://i.imgur.com/6oRxOHv.png" alt="Imgur"></p>
<h2 id="DispatcherServlet的匹配规则"><a href="#DispatcherServlet的匹配规则" class="headerlink" title="DispatcherServlet的匹配规则"></a>DispatcherServlet的匹配规则</h2><p>一般将<code>DispatcherServlet</code>的servletMapping设置成<code>/</code>，这会覆盖Tomcat配置<code>DefaultServlet</code>的servletMapping，<code>DefaultServlet</code>使用来将web根目录下的静态资源返回给客户端的，默认等等servletMapping是<code>/</code>，因此我们将<code>DispatcherServlet</code>的servletMapping也设置成<code>/</code>，会覆盖<code>DefaultServlet</code>的servletMapping（实际上就是将<code>DefaultServlet</code>的servletMapping移除），然后<code>DefaultServlet</code>就不能匹配到任何路径了，所以我们就无法将web根目录下的静态资源返回给客户端了。</p>
<p>如果我们还需要像<code>DefaultServlet</code>一样将web根目录下的静态资源返回给客户端，可以启用<code>DefaultServletHttpRequestHandler</code>这个handler，它匹配的路径为<code>/*</code>，它会把请求获取web目录下的静态资源的请求转发给<code>DefaultServlet</code>处理（<code>DefaultServlet</code>没有了servletMapping，但是我们依然可以通过<code>ServletContext</code>的getNamedDispatcher来根据名称获取到<code>DefaultServlet</code>的<code>RequestDispatcher</code>，然后将请求转发给它处理）。只需要实现<code>WebMvcConfigure</code>接口的configureDefaultServletHandling方法，然后调用方法的参数的enable方法，就可以启用<code>DefaultServletHttpRequestHandler</code>了<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> </span>&#123;</span><br><span class="line">    configurer.enable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>效果如下：</p>
<p><img src="https://i.imgur.com/n11g6ae.png" alt="Imgur"></p>
<p>m.html页面放在web应用根目录下，如果放在WEB-INF目录下，是不能被直接访问的</p>
<p><img src="https://i.imgur.com/FleBKWU.png" alt="Imgur"></p>
<p>可以看到成功地访问到了m.html页面</p>
<h2 id="将各种resolver和属性绑定到request"><a href="#将各种resolver和属性绑定到request" class="headerlink" title="将各种resolver和属性绑定到request"></a>将各种resolver和属性绑定到request</h2><p>在<code>DispatcherServlet</code>将请求分发给handler处理之前，它会把各种resolver（LocaleResolve, ThemeResolver等）还有一些重要的属性绑定到request，以便在后续处理中(主要是让handler和view对象使用)能使用这些resolver和属性处理请求。具体可以看它的doService方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	logRequest(request);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Keep a snapshot of the request attributes in case of an include,</span></span><br><span class="line">	<span class="comment">// to be able to restore the original attributes after the include.</span></span><br><span class="line">       <span class="comment">// 为了节省空间删除了部分代码，因此这里的方法是不完整的，可以在源码中查看完整的方法</span></span><br><span class="line">	<span class="comment">// Make framework objects available to handlers and view objects.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 绑定WebApplicationContext到request</span></span><br><span class="line">	request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());</span><br><span class="line">       <span class="comment">// 绑定LocaleResolver到request</span></span><br><span class="line">	request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.localeResolver);</span><br><span class="line">	<span class="comment">// 绑定ThemeResolver到request</span></span><br><span class="line">	request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.themeResolver);</span><br><span class="line">	<span class="comment">// 绑定ThemeSource到request</span></span><br><span class="line">	request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.flashMapManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">		FlashMap inputFlashMap = <span class="keyword">this</span>.flashMapManager.retrieveAndUpdate(request, response);</span><br><span class="line">		<span class="keyword">if</span> (inputFlashMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">			request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span><br><span class="line">		&#125;</span><br><span class="line">		request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="keyword">new</span> FlashMap());</span><br><span class="line">		request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="keyword">this</span>.flashMapManager);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		doDispatch(request, response);</span><br><span class="line">	&#125;</span><br><span class="line">       <span class="comment">// 删除了后面的部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="解析Multipart"><a href="#解析Multipart" class="headerlink" title="解析Multipart"></a>解析Multipart</h2><p>如果这个请求是一个Multipart请求（某个请求头的值含有multipart字样），就使用<code>MultipartResolver</code>把请求转换成<code>MultipartHttpServletRequest</code>，具体过程可以看<code>DispatcherServlet</code>的checkMultipart方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convert the request into a multipart request, and make multipart resolver available.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If no multipart resolver is set, simply use the existing request.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request current HTTP request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the processed request (multipart wrapper if necessary)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> MultipartResolver#resolveMultipart</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> HttpServletRequest <span class="title">checkMultipart</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> MultipartException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.multipartResolver != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.multipartResolver.isMultipart(request)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (WebUtils.getNativeRequest(request, MultipartHttpServletRequest.class) != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (request.getDispatcherType().equals(DispatcherType.REQUEST)) &#123;</span><br><span class="line">				logger.trace(<span class="string">"Request already resolved to MultipartHttpServletRequest, e.g. by MultipartFilter"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (hasMultipartException(request) ) &#123;</span><br><span class="line">			logger.debug(<span class="string">"Multipart resolution previously failed for current request - "</span> +</span><br><span class="line">					<span class="string">"skipping re-resolution for undisturbed error rendering"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">this</span>.multipartResolver.resolveMultipart(request);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (MultipartException ex) &#123;</span><br><span class="line">				<span class="keyword">if</span> (request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) != <span class="keyword">null</span>) &#123;</span><br><span class="line">					logger.debug(<span class="string">"Multipart resolution failed for error dispatch"</span>, ex);</span><br><span class="line">					<span class="comment">// Keep processing error dispatch with regular request handle below</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">throw</span> ex;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// If not returned before: return original request.</span></span><br><span class="line">	<span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有配置<code>MultipartResolver</code>，就将请求原样返回，不作任何转换，这是因为真正的转换是调用<code>MultipartResolver</code>的resolveMultipart进行的，没有<code>MultipartResolver</code>，就无法转换了。默认情况下<code>MultipartResolver</code>是没有被配置的，因此不能处理Multipart请求，需要我们自己去配置。Spring模块中有两个具体的<code>MultipartResolver</code>类，分别为<code>CommonsMultipartResolver</code>和<code>StandardServletMultipartResolver</code>，一般我们会选择配置<code>CommonsMultipartResolver</code>，因为它配置比较简单，只需要在配置类中声明一个id为multipartResolver的Bean就行了（还要添加相应的依赖包，比如Apache Commons IO）。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">MultipartResolver <span class="title">multipartResolver</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CommonsMultipartResolver();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="根据请求路径找到匹配的handler"><a href="#根据请求路径找到匹配的handler" class="headerlink" title="根据请求路径找到匹配的handler"></a>根据请求路径找到匹配的handler</h2><p>将会调用<code>DispatcherServlet</code>的getHandler方法来寻找所以匹配的handler<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the HandlerExecutionChain for this request.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Tries all handler mappings in order.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request current HTTP request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the HandlerExecutionChain, or &#123;<span class="doctag">@code</span> null&#125; if no handler could be found</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (HandlerMapping mapping : <span class="keyword">this</span>.handlerMappings) &#123;</span><br><span class="line">			HandlerExecutionChain handler = mapping.getHandler(request);</span><br><span class="line">			<span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> handler;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>getHandler方法的返回类型为<code>HandlerExecutionChain</code><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerExecutionChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Object handler;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> HandlerInterceptor[] interceptors;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> List&lt;HandlerInterceptor&gt; interceptorList;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> interceptorIndex = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>HandlerExecutionChain</code>里面存放了一个handler，还有多个<code>HandlerInterceptor</code>，说明一个请求路径可能匹配最多一个handler，但是能匹配多个<code>HandlerInterceptor</code>。</p>
<p>getHandler方法具体是怎样将请求路径和对应的handler还有<code>HandlerExecutionChain</code>匹配起来的，这是一个重点，从<code>DispatcherServlet</code>的getHandler方法中可以看到是遍历handlerMappings变量，然后调用<code>HandlerMapping</code>实例的getHandler方法。那么handlerMappings变量里面都有哪些<code>HandlerMapping</code>实例呢？我们可以去看<code>DispatcherServlet</code>的initHandlerMappings方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initHandlerMappings</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.handlerMappings = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// this.detectAllHandlerMappings的值默认为true</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.detectAllHandlerMappings) &#123;</span><br><span class="line">		<span class="comment">// Find all HandlerMappings in the ApplicationContext, including ancestor contexts.</span></span><br><span class="line">		<span class="comment">// 将查找所有实现了HandlerMapping接口的Bean</span></span><br><span class="line">		Map&lt;String, HandlerMapping&gt; matchingBeans =</span><br><span class="line">				BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">if</span> (!matchingBeans.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">this</span>.handlerMappings = <span class="keyword">new</span> ArrayList&lt;&gt;(matchingBeans.values());</span><br><span class="line">			<span class="comment">// We keep HandlerMappings in sorted order.</span></span><br><span class="line">			AnnotationAwareOrderComparator.sort(<span class="keyword">this</span>.handlerMappings);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			HandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);</span><br><span class="line">			<span class="keyword">this</span>.handlerMappings = Collections.singletonList(hm);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">			<span class="comment">// Ignore, we'll add a default HandlerMapping later.</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Ensure we have at least one HandlerMapping, by registering</span></span><br><span class="line">	<span class="comment">// a default HandlerMapping if no other mappings are found.</span></span><br><span class="line">	<span class="comment">// 如果没有没有在IOC容器里面找到类型为HandlerMapping的Bean，则使用默认的HandlerMapping</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">this</span>.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">"No HandlerMappings declared for servlet '"</span> + getServletName() +</span><br><span class="line">					<span class="string">"': using default strategies from DispatcherServlet.properties"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，添加了@EnableWebMvc注解后，在<code>WebMvcConfigurationSupport</code>类中，会配置5个实现了<code>HandlerMapping</code>类型的Bean</p>
<p>第一个Bean为requestMappingHandlerMapping<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return a &#123;<span class="doctag">@link</span> RequestMappingHandlerMapping&#125; ordered at 0 for mapping</span></span><br><span class="line"><span class="comment"> * requests to annotated controllers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestMappingHandlerMapping <span class="title">requestMappingHandlerMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	RequestMappingHandlerMapping mapping = createRequestMappingHandlerMapping();</span><br><span class="line">	mapping.setOrder(<span class="number">0</span>);</span><br><span class="line">	......<span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二个Bean为viewControllerHandlerMapping<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return a handler mapping ordered at 1 to map URL paths directly to</span></span><br><span class="line"><span class="comment"> * view names. To configure view controllers, override</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #addViewControllers&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HandlerMapping <span class="title">viewControllerHandlerMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ViewControllerRegistry registry = <span class="keyword">new</span> ViewControllerRegistry(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">	addViewControllers(registry);</span><br><span class="line"></span><br><span class="line">	AbstractHandlerMapping handlerMapping = registry.buildHandlerMapping();</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第三个Bean为beanNameHandlerMapping<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return a &#123;<span class="doctag">@link</span> BeanNameUrlHandlerMapping&#125; ordered at 2 to map URL</span></span><br><span class="line"><span class="comment"> * paths to controller bean names.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanNameUrlHandlerMapping <span class="title">beanNameHandlerMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	BeanNameUrlHandlerMapping mapping = <span class="keyword">new</span> BeanNameUrlHandlerMapping();</span><br><span class="line">	mapping.setOrder(<span class="number">2</span>);</span><br><span class="line">	mapping.setInterceptors(getInterceptors());</span><br><span class="line">	mapping.setCorsConfigurations(getCorsConfigurations());</span><br><span class="line">	<span class="keyword">return</span> mapping;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第四个Bean为resourceHandlerMapping<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return a handler mapping ordered at Integer.MAX_VALUE-1 with mapped</span></span><br><span class="line"><span class="comment"> * resource handlers. To configure resource handling, override</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #addResourceHandlers&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HandlerMapping <span class="title">resourceHandlerMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ResourceHandlerRegistry registry = <span class="keyword">new</span> ResourceHandlerRegistry(<span class="keyword">this</span>.applicationContext,</span><br><span class="line">			<span class="keyword">this</span>.servletContext, mvcContentNegotiationManager(), mvcUrlPathHelper());</span><br><span class="line">	addResourceHandlers(registry);</span><br><span class="line"></span><br><span class="line">	AbstractHandlerMapping handlerMapping = registry.getHandlerMapping();</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第五个Bean为defaultServletHandlerMapping<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return a handler mapping ordered at Integer.MAX_VALUE with a mapped</span></span><br><span class="line"><span class="comment"> * default servlet handler. To configure "default" Servlet handling,</span></span><br><span class="line"><span class="comment"> * override &#123;<span class="doctag">@link</span> #configureDefaultServletHandling&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HandlerMapping <span class="title">defaultServletHandlerMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	DefaultServletHandlerConfigurer configurer = <span class="keyword">new</span> DefaultServletHandlerConfigurer(<span class="keyword">this</span>.servletContext);</span><br><span class="line">	configureDefaultServletHandling(configurer);</span><br><span class="line">	<span class="keyword">return</span> configurer.buildHandlerMapping();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的代码无法直接看出第2,4,5Bean的具体类型，即viewControllerHandlerMapping，Bean为resourceHandlerMapping，defaultServletHandlerMapping，跟进去对应的方法里面应该可以看出来，但是可以直接DEBUG设置断点快速查看对应的类型</p>
<p><img src="https://i.imgur.com/Uo8T18X.png" alt="Imgur"></p>
<p>从上面的图中可以看出来，是<code>SimpleUrlHandlerMapping</code>类型</p>
<p>其中，第一个Bean的Order的值设置成了0，因此优先级最高，所以默认先调用<code>RequestMappingHandlerMapping</code>的getHandler方法获取相应的handler，然而这个类里面并没有这个方法，说明是从父类继承的，最终在<code>AbstractHandlerMapping</code>类中发现了这个方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="comment">// 调用getHandlerInternal方法获取handler，这个方法需要子类实现</span></span><br><span class="line">	Object handler = getHandlerInternal(request);</span><br><span class="line">	<span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 没有获取到handler，则尝试获取默认的handler</span></span><br><span class="line">		handler = getDefaultHandler();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Bean name or resolved handler?</span></span><br><span class="line">	<span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">		String handlerName = (String) handler;</span><br><span class="line">		handler = obtainApplicationContext().getBean(handlerName);</span><br><span class="line">	&#125;</span><br><span class="line">       <span class="comment">// 获取HandlerExecutionChain，这里会找到所有匹配的拦截器</span></span><br><span class="line">	HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);</span><br><span class="line">	...... <span class="comment">// 删除了部分代码</span></span><br><span class="line">	<span class="keyword">return</span> executionChain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到还需要调用getHandlerInternal方法获取handler<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure></p>
<p>getHandlerInternal是抽象方法，说明是留给子类实现了，所以这里又使用了模板方法模式，<code>AbstractHandlerMapping</code>的直接子类<code>AbstractHandlerMethodMapping&lt;T&gt;</code>实现了这个方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> HandlerMethod <span class="title">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);</span><br><span class="line">	<span class="keyword">this</span>.mappingRegistry.acquireReadLock();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 调用lookupHandlerMethod方法，使用上面的lookupPath找到对应的HandlerMethod</span></span><br><span class="line">		HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request);</span><br><span class="line">		<span class="keyword">return</span> (handlerMethod != <span class="keyword">null</span> ? handlerMethod.createWithResolvedBean() : <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">this</span>.mappingRegistry.releaseReadLock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>getHandlerInternal大概的逻辑是，根据请求的路径，即lookupPath，调用lookupHandlerMethod找到对应的<code>HandlerMethod</code>，<code>HandlerMethod</code>又是什么东西？？？<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Encapsulates information about a handler method consisting of a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@linkplain</span> #getMethod() method&#125; and a &#123;<span class="doctag">@linkplain</span> #getBean() bean&#125;.</span></span><br><span class="line"><span class="comment"> * Provides convenient access to method parameters, the method return value,</span></span><br><span class="line"><span class="comment"> * method annotations, etc.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The class may be created with a bean instance or with a bean name</span></span><br><span class="line"><span class="comment"> * (e.g. lazy-init bean, prototype bean). Use &#123;<span class="doctag">@link</span> #createWithResolvedBean()&#125;</span></span><br><span class="line"><span class="comment"> * to obtain a &#123;<span class="doctag">@code</span> HandlerMethod&#125; instance with a bean instance resolved</span></span><br><span class="line"><span class="comment"> * through the associated &#123;<span class="doctag">@link</span> BeanFactory&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Object bean;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; beanType;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Method method;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Method bridgedMethod;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> MethodParameter[] parameters;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> HttpStatus responseStatus;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> String responseStatusReason;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> HandlerMethod resolvedFromHandlerMethod;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;Annotation[][]&gt; interfaceParameterAnnotations;</span><br><span class="line">	...... <span class="comment">//主要存放了上面的几个成员变量</span></span><br></pre></td></tr></table></figure></p>
<p>简单来说就是一个方法 + 方法所属对象的组合，举个例子<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span></span>&#123;</span><br><span class="line">	<span class="meta">@GetMaping</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"index.html"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的index方法，将会是<code>HandlerMethod</code>里面的method变量的值，然后IndexController上面有@Controller注解，所以它是一个Bean，会被容器创建，Bean名成为”indexController”，<br>所以这个Bean将会是上面的<code>HandlerMethod</code>的bean变量的值</p>
<p>然后来看看lookupHandlerMethod方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> HandlerMethod <span class="title">lookupHandlerMethod</span><span class="params">(String lookupPath, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	List&lt;Match&gt; matches = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	List&lt;T&gt; directPathMatches = <span class="keyword">this</span>.mappingRegistry.getMappingsByUrl(lookupPath);</span><br><span class="line">	<span class="keyword">if</span> (directPathMatches != <span class="keyword">null</span>) &#123;</span><br><span class="line">		addMatchingMappings(directPathMatches, matches, request);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (matches.isEmpty()) &#123;</span><br><span class="line">		<span class="comment">// No choice but to go through all mappings...</span></span><br><span class="line">		addMatchingMappings(<span class="keyword">this</span>.mappingRegistry.getMappings().keySet(), matches, request);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!matches.isEmpty()) &#123;</span><br><span class="line">		Comparator&lt;Match&gt; comparator = <span class="keyword">new</span> MatchComparator(getMappingComparator(request));</span><br><span class="line">		matches.sort(comparator);</span><br><span class="line">		Match bestMatch = matches.get(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (matches.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(matches.size() + <span class="string">" matching mappings: "</span> + matches);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (CorsUtils.isPreFlightRequest(request)) &#123;</span><br><span class="line">				<span class="keyword">return</span> PREFLIGHT_AMBIGUOUS_MATCH;</span><br><span class="line">			&#125;</span><br><span class="line">			Match secondBestMatch = matches.get(<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span> (comparator.compare(bestMatch, secondBestMatch) == <span class="number">0</span>) &#123;</span><br><span class="line">				Method m1 = bestMatch.handlerMethod.getMethod();</span><br><span class="line">				Method m2 = secondBestMatch.handlerMethod.getMethod();</span><br><span class="line">				String uri = request.getRequestURI();</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">						<span class="string">"Ambiguous handler methods mapped for '"</span> + uri + <span class="string">"': &#123;"</span> + m1 + <span class="string">", "</span> + m2 + <span class="string">"&#125;"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		handleMatch(bestMatch.mapping, lookupPath, request);</span><br><span class="line">		<span class="keyword">return</span> bestMatch.handlerMethod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> handleNoMatch(<span class="keyword">this</span>.mappingRegistry.getMappings().keySet(), lookupPath, request);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实际上就是把mappingRegistry变量（类型为<code>MappingRegistry</code>）里面的urlLookup变量（类型为<code>MultiValueMap&lt;String, T&gt;</code>）的值通过lookupPath（即请求路径）取出来，<code>MultiValueMap</code>是一个键对应多个值的一种特殊Map，因此能够得到多个值，然后在用这些值创建<code>Match</code>的实例，放到<code>Match</code>列表中，如果<code>Match</code>列表有多个<code>Match</code>元素，则从中选出一个best-matching（最匹配）的一个，那<code>Match</code>又是什么东西（感觉HandlerMapping应该单独再写一篇博客来总结，内容实在太多了），实际上它就是把上面的<code>MultiValueMap&lt;String, T&gt;</code>类型里面的T类型的元素和<code>HandlerMethod</code>绑定起来，方便选出最匹配的<code>Match</code>，最后返回最匹配的<code>Match</code>的<code>HandlerMethod</code>变量。所以最终最多只会选出一个<code>HandlerMethod</code>，也就是一个请求只能匹配到一个handler</p>
<p>到这里终于匹配完相应的handler了，让我们回到<code>AbstractHandlerMapping</code>的getHandler方法，现在它已经匹配到相应的handler了，之后它会调用getHandlerExecutionChain方法获取<code>HandlerExecutionChain</code>，下面来看getHandlerExecutionChain方法，这个方法也是在<code>AbstractHandlerMapping</code>类里面<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandlerExecutionChain</span><span class="params">(Object handler, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">	HandlerExecutionChain chain = (handler <span class="keyword">instanceof</span> HandlerExecutionChain ?</span><br><span class="line">			(HandlerExecutionChain) handler : <span class="keyword">new</span> HandlerExecutionChain(handler));</span><br><span class="line"></span><br><span class="line">	String lookupPath = <span class="keyword">this</span>.urlPathHelper.getLookupPathForRequest(request);</span><br><span class="line">	<span class="keyword">for</span> (HandlerInterceptor interceptor : <span class="keyword">this</span>.adaptedInterceptors) &#123;</span><br><span class="line">		<span class="keyword">if</span> (interceptor <span class="keyword">instanceof</span> MappedInterceptor) &#123;</span><br><span class="line">			MappedInterceptor mappedInterceptor = (MappedInterceptor) interceptor;</span><br><span class="line">			<span class="keyword">if</span> (mappedInterceptor.matches(lookupPath, <span class="keyword">this</span>.pathMatcher)) &#123;</span><br><span class="line">				chain.addInterceptor(mappedInterceptor.getInterceptor());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			chain.addInterceptor(interceptor);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> chain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>粗略地讲，这个方法会将请求路径匹配的所有拦截器添加到<code>HandlerExecutionChain</code>的实例中，然后返回该实例，最终我们就能得到<code>HandlerExecutionChain</code>实例了。</p>
<h2 id="获取对应的HandlerAdapter"><a href="#获取对应的HandlerAdapter" class="headerlink" title="获取对应的HandlerAdapter"></a>获取对应的HandlerAdapter</h2><p><code>HandlerAdapter</code>是调用getHandlerAdapter方法获取的，这个方法在<code>DispatcherServlet</code>里面<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerAdapter <span class="title">getHandlerAdapter</span><span class="params">(Object handler)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.handlerAdapters != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (HandlerAdapter adapter : <span class="keyword">this</span>.handlerAdapters) &#123;</span><br><span class="line">			<span class="keyword">if</span> (adapter.supports(handler)) &#123;</span><br><span class="line">				<span class="keyword">return</span> adapter;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"No adapter for handler ["</span> + handler +</span><br><span class="line">			<span class="string">"]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法很简单，就是遍历<code>DispatcherServlet</code>预先配置好的handlerAdapters，如果遍历到的<code>HandlerAdapter</code>支持处理前面匹配到的handler,那么就直接返回这个<code>HandlerAdapter</code>。</p>
<p>所以关键要看<code>DispatcherServlet</code>是怎样初始化handlerAdapters的。handlerAdapters的初始化是调用<code>DispatcherServlet</code>的initHandlerAdapters方法完成的<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initHandlerAdapters</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.handlerAdapters = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.detectAllHandlerAdapters) &#123;</span><br><span class="line">		<span class="comment">// Find all HandlerAdapters in the ApplicationContext, including ancestor contexts.</span></span><br><span class="line">	    <span class="comment">// 这里的逻辑和初始化HandlerMappingg类似</span></span><br><span class="line">	    <span class="comment">// 找到所有实现了HandlerAdapter接口的Bean</span></span><br><span class="line">		Map&lt;String, HandlerAdapter&gt; matchingBeans =</span><br><span class="line">				BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerAdapter.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">if</span> (!matchingBeans.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">this</span>.handlerAdapters = <span class="keyword">new</span> ArrayList&lt;&gt;(matchingBeans.values());</span><br><span class="line">			<span class="comment">// We keep HandlerAdapters in sorted order.</span></span><br><span class="line">			AnnotationAwareOrderComparator.sort(<span class="keyword">this</span>.handlerAdapters);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			HandlerAdapter ha = context.getBean(HANDLER_ADAPTER_BEAN_NAME, HandlerAdapter.class);</span><br><span class="line">			<span class="keyword">this</span>.handlerAdapters = Collections.singletonList(ha);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">			<span class="comment">// Ignore, we'll add a default HandlerAdapter later.</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Ensure we have at least some HandlerAdapters, by registering</span></span><br><span class="line">	<span class="comment">// default HandlerAdapters if no other adapters are found.</span></span><br><span class="line">	<span class="comment">// 没有配置HandlerAdapter，就采用默认的配置</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.handlerAdapters == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">this</span>.handlerAdapters = getDefaultStrategies(context, HandlerAdapter.class);</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">"No HandlerAdapters declared for servlet '"</span> + getServletName() +</span><br><span class="line">					<span class="string">"': using default strategies from DispatcherServlet.properties"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到它的逻辑和初始化<code>HandlerMapping</code>是类似的，都是找到实现了某个接口等所有Bean，如果这样的Bean存在，则把它们排序后放到列表中，如果不存在，则采用默认的配置(默认的配置在DispatcherServlet.properties文件中，相应的值为org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping)。</p>
<p>在添加<code>@EnableWebMvc</code>注解后，在<code>WebMvcConfigurationSupport</code>类中，会配置多个实现了<code>HandlerMapping</code>接口的Bean<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestMappingHandlerAdapter <span class="title">requestMappingHandlerAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	RequestMappingHandlerAdapter adapter = createRequestMappingHandlerAdapter();</span><br><span class="line">	adapter.setContentNegotiationManager(mvcContentNegotiationManager());</span><br><span class="line">	adapter.setMessageConverters(getMessageConverters());</span><br><span class="line">	adapter.setWebBindingInitializer(getConfigurableWebBindingInitializer());</span><br><span class="line">	adapter.setCustomArgumentResolvers(getArgumentResolvers());</span><br><span class="line">	adapter.setCustomReturnValueHandlers(getReturnValueHandlers());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (jackson2Present) &#123;</span><br><span class="line">		adapter.setRequestBodyAdvice(Collections.singletonList(<span class="keyword">new</span> JsonViewRequestBodyAdvice()));</span><br><span class="line">		adapter.setResponseBodyAdvice(Collections.singletonList(<span class="keyword">new</span> JsonViewResponseBodyAdvice()));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	AsyncSupportConfigurer configurer = <span class="keyword">new</span> AsyncSupportConfigurer();</span><br><span class="line">	configureAsyncSupport(configurer);</span><br><span class="line">	<span class="keyword">if</span> (configurer.getTaskExecutor() != <span class="keyword">null</span>) &#123;</span><br><span class="line">		adapter.setTaskExecutor(configurer.getTaskExecutor());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (configurer.getTimeout() != <span class="keyword">null</span>) &#123;</span><br><span class="line">		adapter.setAsyncRequestTimeout(configurer.getTimeout());</span><br><span class="line">	&#125;</span><br><span class="line">	adapter.setCallableInterceptors(configurer.getCallableInterceptors());</span><br><span class="line">	adapter.setDeferredResultInterceptors(configurer.getDeferredResultInterceptors());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> adapter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到配置的<code>HandlerAdapter</code>具体实现类为<code>RequestMappingHandlerAdapter</code><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Extension of &#123;<span class="doctag">@link</span> AbstractHandlerMethodAdapter&#125; that supports</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> RequestMapping&#125; annotated &#123;<span class="doctag">@code</span> HandlerMethod RequestMapping&#125; annotated &#123;<span class="doctag">@code</span> HandlerMethods&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Support for custom argument and return value types can be added via</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #setCustomArgumentResolvers&#125; and &#123;<span class="doctag">@link</span> #setCustomReturnValueHandlers&#125;,</span></span><br><span class="line"><span class="comment"> * or alternatively, to re-configure all argument and return value types,</span></span><br><span class="line"><span class="comment"> * use &#123;<span class="doctag">@link</span> #setArgumentResolvers&#125; and &#123;<span class="doctag">@link</span> #setReturnValueHandlers&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br></pre></td></tr></table></figure></p>
<p>看它的注解，发现这个类是标注有<code>@RequestMapping</code>的handler（<code>HandlerMethod</code>类型，因为被<code>@RequestMapping</code>标注的方法会被自动发现然后创建一个相应的<code>HandlerMethod</code>）的支撑类，用来执行这类handler。<code>RequestMappingHandlerAdapter</code>内部做了很多工作，比如配置HandlerMethodArgumentResolver，配置HttpMessageConverter等（内容有点多了，需要再写一篇博客单独讲解）</p>
<p>在后面DEBUG设置断点查看具体会创建多少个<code>HandlerAdapter</code>的时候，发现一个有3个</p>
<p><img src="https://i.imgur.com/79hCOpf.png" alt="Imgur"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a &#123;<span class="doctag">@link</span> HttpRequestHandlerAdapter&#125; for processing requests</span></span><br><span class="line"><span class="comment"> * with &#123;<span class="doctag">@link</span> HttpRequestHandler HttpRequestHandlers&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HttpRequestHandlerAdapter <span class="title">httpRequestHandlerAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> HttpRequestHandlerAdapter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a &#123;<span class="doctag">@link</span> SimpleControllerHandlerAdapter&#125; for processing requests</span></span><br><span class="line"><span class="comment"> * with interface-based controllers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleControllerHandlerAdapter <span class="title">simpleControllerHandlerAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> SimpleControllerHandlerAdapter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的是遗漏的其他两个<code>HandlerAdapter</code></p>
<h2 id="调用拦截器的preHandle方法"><a href="#调用拦截器的preHandle方法" class="headerlink" title="调用拦截器的preHandle方法"></a>调用拦截器的preHandle方法</h2><p>获取到了<code>HandlerAdapter</code>之后，就可以调用它的handle方法调用handler了，不过由于拦截器（<code>HandlerInterceptor</code>）的preHandle方法是要在handler调用之前执行的，所以首先要把<code>HandlerExecutionChain</code>里面的所有拦截器的preHandle方法执行一遍。</p>
<p>我们回到<code>DispatcherHandler</code>的doDispatch方法，可以看到是调用<code>HandlerExecutionChain</code>的applyPreHandle方法执行拦截器的preHandle方法的，所以我们来看<code>HandlerExecutionChain</code>的applyPreHandle方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Apply preHandle methods of registered interceptors.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the execution chain should proceed with the</span></span><br><span class="line"><span class="comment"> * next interceptor or the handler itself. Else, DispatcherServlet assumes</span></span><br><span class="line"><span class="comment"> * that this interceptor has already dealt with the response itself.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">applyPreHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="comment">// 获取该实例中所有的HandlerInterceptor</span></span><br><span class="line">	HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">	<span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interceptors.length; i++) &#123;</span><br><span class="line">			遍历素有的HandlerInterceptor，逐个执行perHandle方法</span><br><span class="line">			HandlerInterceptor interceptor = interceptors[i];</span><br><span class="line">			<span class="keyword">if</span> (!interceptor.preHandle(request, response, <span class="keyword">this</span>.handler)) &#123;</span><br><span class="line">				<span class="comment">// 如果preHandle返回false，则认为它已经自己处理好请求并返回给了客户端</span></span><br><span class="line">				<span class="comment">// 后面的拦截器不需要再执行了，而且认为本次请求已经完成，所以调用拦截器的afterCompletion方法</span></span><br><span class="line">				triggerAfterCompletion(request, response, <span class="keyword">null</span>);</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">this</span>.interceptorIndex = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> HandlerInterceptor[] getInterceptors() &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.interceptors == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.interceptorList != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">this</span>.interceptors = <span class="keyword">this</span>.interceptorList.toArray(<span class="keyword">new</span> HandlerInterceptor[<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.interceptors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法就是把<code>HandlerExecutionChain</code>实例中所有的拦截器的preHandle都执行一遍（假设全部都返回true），如果preHandle方法返回了false，则表示不需要调用后面未执行的拦截器的preHandle方法了，而且认为返回false的preHandle方法已经向客户端返回了数据，本次请求已经完成了，所以后面会直接调用拦截器的afterCompletino方法。</p>
<h2 id="调用handler"><a href="#调用handler" class="headerlink" title="调用handler"></a>调用handler</h2><p>终于到了真正调用handler这一步了，还是在<code>DispatcherHandler</code>的doDispatch方法里面，可以看到是调用<code>HandlerAdapter</code>的handle方法来调用handler的，假设我们前面获取到的handler是<code>HandlerMethod</code>类型的，则我们的<code>HandlerAdapter</code>将会是<code>RequestMappingHandlerAdapter</code>，所以我们来看到<code>RequestMappingHandlerAdapter</code>的handler方法，然后发现这个类里面没有这个方法，所以这个方法是从它的父类<code>AbstractHandlerMethodAdapter</code>继承的，<code>AbstractHandlerMethodAdapter</code>的handle方法如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">// 调用了handleInternal方法，这是一个抽象方法</span></span><br><span class="line">	<span class="keyword">return</span> handleInternal(request, response, (HandlerMethod) handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> ModelAndView <span class="title">handleInternal</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">		HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure></p>
<p>可以看到具体的实现其实是在handleInternal里面，而这是一个抽象方法，需要子类实现，<code>RequestMappingHandlerAdapter</code>实现了这个方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">handleInternal</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">		HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">	ModelAndView mav;</span><br><span class="line">	<span class="comment">// 检查是否支持处理这个请求和是否需要session</span></span><br><span class="line">	checkRequest(request);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Execute invokeHandlerMethod in synchronized block if required.</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.synchronizeOnSession) &#123;</span><br><span class="line">		HttpSession session = request.getSession(<span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">			Object mutex = WebUtils.getSessionMutex(session);</span><br><span class="line">			<span class="keyword">synchronized</span> (mutex) &#123;</span><br><span class="line">				mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// No HttpSession available -&gt; no mutex necessary</span></span><br><span class="line">			mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// No synchronization on session demanded at all...</span></span><br><span class="line">		mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!response.containsHeader(HEADER_CACHE_CONTROL)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123;</span><br><span class="line">			applyCacheSeconds(response, <span class="keyword">this</span>.cacheSecondsForSessionAttributeHandlers);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			prepareResponse(response);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后重点看invokeHandlerMethod方法，这个方法返回一个<code>ModelAndView</code>，以便后面进行视图解析和渲染等操作<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">invokeHandlerMethod</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">		HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">	ServletWebRequest webRequest = <span class="keyword">new</span> ServletWebRequest(request, response);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);</span><br><span class="line">		ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);</span><br><span class="line"></span><br><span class="line">		ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers != <span class="keyword">null</span>) &#123;</span><br><span class="line">			invocableMethod.setHandlerMethodArgumentResolvers(<span class="keyword">this</span>.argumentResolvers);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.returnValueHandlers != <span class="keyword">null</span>) &#123;</span><br><span class="line">			invocableMethod.setHandlerMethodReturnValueHandlers(<span class="keyword">this</span>.returnValueHandlers);</span><br><span class="line">		&#125;</span><br><span class="line">		invocableMethod.setDataBinderFactory(binderFactory);</span><br><span class="line">		invocableMethod.setParameterNameDiscoverer(<span class="keyword">this</span>.parameterNameDiscoverer);</span><br><span class="line"></span><br><span class="line">		ModelAndViewContainer mavContainer = <span class="keyword">new</span> ModelAndViewContainer();</span><br><span class="line">		mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));</span><br><span class="line">		modelFactory.initModel(webRequest, mavContainer, invocableMethod);</span><br><span class="line">		mavContainer.setIgnoreDefaultModelOnRedirect(<span class="keyword">this</span>.ignoreDefaultModelOnRedirect);</span><br><span class="line"></span><br><span class="line">		AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);</span><br><span class="line">		asyncWebRequest.setTimeout(<span class="keyword">this</span>.asyncRequestTimeout);</span><br><span class="line"></span><br><span class="line">		WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">		asyncManager.setTaskExecutor(<span class="keyword">this</span>.taskExecutor);</span><br><span class="line">		asyncManager.setAsyncWebRequest(asyncWebRequest);</span><br><span class="line">		asyncManager.registerCallableInterceptors(<span class="keyword">this</span>.callableInterceptors);</span><br><span class="line">		asyncManager.registerDeferredResultInterceptors(<span class="keyword">this</span>.deferredResultInterceptors);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (asyncManager.hasConcurrentResult()) &#123;</span><br><span class="line">			Object result = asyncManager.getConcurrentResult();</span><br><span class="line">			mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[<span class="number">0</span>];</span><br><span class="line">			asyncManager.clearConcurrentResult();</span><br><span class="line">			LogFormatUtils.traceDebug(logger, traceOn -&gt; &#123;</span><br><span class="line">				String formatted = LogFormatUtils.formatValue(result, !traceOn);</span><br><span class="line">				<span class="keyword">return</span> <span class="string">"Resume with async result ["</span> + formatted + <span class="string">"]"</span>;</span><br><span class="line">			&#125;);</span><br><span class="line">			invocableMethod = invocableMethod.wrapConcurrentResult(result);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line">		<span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		webRequest.requestCompleted();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法做的东西很多而且很核心，内容有点多，所以也将单独写一篇博客进行讲解和总结。可以看到这个方法将会创建一个<code>ServletInvocableHandlerMethod</code>对象，然后为它设置好参数解析器等东西，调用<code>ServletInvocableHandlerMethod</code>的invokeAndHandle方法，最后根据调用结果创建<code>ModelAndView</code>对象并返回</p>
<h2 id="调用拦截器的postHandle方法"><a href="#调用拦截器的postHandle方法" class="headerlink" title="调用拦截器的postHandle方法"></a>调用拦截器的postHandle方法</h2><p>调用完<code>HandlerAdapter</code>的handle方法之后，handle已经执行完成了，并返回了相应的<code>ModelAndView</code>对象。因为拦截器的postHandle方法是在handler执行完之后再执行的，因此后面将会执行拦截器的postHandler方法，在<code>DispatcherServlet</code>的doDispatch方法中，可以看到将会调用<code>HandlerExecutionChain</code>的applyPostHandle方法执行拦截器的postHandler方法（前面还有一个applyDefaultViewName被我跳过了，这个是用来解析默认的视图名称的）<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">applyPostHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, @Nullable ModelAndView mv)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">	HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">	<span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = interceptors.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			HandlerInterceptor interceptor = interceptors[i];</span><br><span class="line">			interceptor.postHandle(request, response, <span class="keyword">this</span>.handler, mv);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到和applypreHandle方法差不多，不过applyPostHandle是由最后一个<code>HandlerInterceptor</code>开始倒过来执行postHandle方法的，这和applypreHandle方法相反。</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>如果上面的步骤抛出了异常，就返回异常相关的<code>ModelAndView</code>，具体处理流程如下（在<code>DispatchreServlet</code>的processDispatchResult方法中）：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> errorView = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="comment">// 如果异常是ModelAndViewDefiningException类型的，则直接获取里面的ModelAndView</span></span><br><span class="line">	<span class="keyword">if</span> (exception <span class="keyword">instanceof</span> ModelAndViewDefiningException) &#123;</span><br><span class="line">		logger.debug(<span class="string">"ModelAndViewDefiningException encountered"</span>, exception);</span><br><span class="line">		mv = ((ModelAndViewDefiningException) exception).getModelAndView();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 如果异常是其他类型的，则调用processHandlerException获取与异常相关的ModelAndView</span></span><br><span class="line">		Object handler = (mappedHandler != <span class="keyword">null</span> ? mappedHandler.getHandler() : <span class="keyword">null</span>);</span><br><span class="line">		mv = processHandlerException(request, response, handler, exception);</span><br><span class="line">		errorView = (mv != <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="解析和渲染视图"><a href="#解析和渲染视图" class="headerlink" title="解析和渲染视图"></a>解析和渲染视图</h2><p>如果前面返回的<code>ModelAndView</code>不为空，则调用<code>DispatcherServler</code>的render准备进行视图渲染<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Render the given ModelAndView.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is the last stage in handling a request. It may involve resolving the view by name.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mv the ModelAndView to render</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request current HTTP servlet request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> response current HTTP servlet response</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ServletException if view is missing or cannot be resolved</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception if there's a problem rendering the view</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(ModelAndView mv, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="comment">// Determine locale for request and apply it to the response.</span></span><br><span class="line">	Locale locale =</span><br><span class="line">			(<span class="keyword">this</span>.localeResolver != <span class="keyword">null</span> ? <span class="keyword">this</span>.localeResolver.resolveLocale(request) : request.getLocale());</span><br><span class="line">	response.setLocale(locale);</span><br><span class="line"></span><br><span class="line">	View view;</span><br><span class="line">	String viewName = mv.getViewName();</span><br><span class="line">	<span class="keyword">if</span> (viewName != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// We need to resolve the view name.</span></span><br><span class="line">		view = resolveViewName(viewName, mv.getModelInternal(), locale, request);</span><br><span class="line">		<span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"Could not resolve view with name '"</span> + mv.getViewName() +</span><br><span class="line">					<span class="string">"' in servlet with name '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// No need to lookup: the ModelAndView object contains the actual View object.</span></span><br><span class="line">		view = mv.getView();</span><br><span class="line">		<span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"ModelAndView ["</span> + mv + <span class="string">"] neither contains a view name nor a "</span> +</span><br><span class="line">					<span class="string">"View object in servlet with name '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Delegate to the View object for rendering.</span></span><br><span class="line">	<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">		logger.trace(<span class="string">"Rendering view ["</span> + view + <span class="string">"] "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (mv.getStatus() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			response.setStatus(mv.getStatus().value());</span><br><span class="line">		&#125;</span><br><span class="line">		view.render(mv.getModelInternal(), request, response);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">"Error rendering view ["</span> + view + <span class="string">"]"</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> ex;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先使用LocaleResolver解析请求所属的地区，接着获取视图默认的视图名（<code>ModelAndView</code>里面应该已经有相应的视图名称了），如果不为空则调用resolveViewName方法解析视图</p>
<h3 id="解析视图"><a href="#解析视图" class="headerlink" title="解析视图"></a>解析视图</h3><p>下面来看resolveViewName方法（在<code>DispatcherServlet</code>里面）：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> View <span class="title">resolveViewName</span><span class="params">(String viewName, @Nullable Map&lt;String, Object&gt; model,</span></span></span><br><span class="line"><span class="function"><span class="params">		Locale locale, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.viewResolvers != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (ViewResolver viewResolver : <span class="keyword">this</span>.viewResolvers) &#123;</span><br><span class="line">			View view = viewResolver.resolveViewName(viewName, locale);</span><br><span class="line">			<span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> view;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果视图解析器不为空，则使用调用视图解析器的resolveViewName方法解析视图。那么视图解析器是怎么初始化的呢？和前面的<code>HandlerMapping</code>还有<code>HandlerAdapter</code>一样，也是先查找相应类型的Bean（这里是<code>ViewResolver</code>类型），如果找到的话就添加到viewResolvers变量里面，如果没有找到则使用默认的视图解析器（DispatcherServler.properties文件里面定义的）。</p>
<p>再次去看<code>WebMvcConfigurationSupport</code>这个类，看它有没有配置<code>ViewResolver</code>类型的Bean，发现配置了一个mvcViewResolver，具体类型为<code>ViewResolverComposite</code><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register a &#123;<span class="doctag">@link</span> ViewResolverComposite&#125; that contains a chain of view resolvers</span></span><br><span class="line"><span class="comment"> * to use for view resolution.</span></span><br><span class="line"><span class="comment"> * By default this resolver is ordered at 0 unless content negotiation view</span></span><br><span class="line"><span class="comment"> * resolution is used in which case the order is raised to</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.core.Ordered#HIGHEST_PRECEDENCE</span></span><br><span class="line"><span class="comment"> * Ordered.HIGHEST_PRECEDENCE&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If no other resolvers are configured,</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ViewResolverComposite#resolveViewName(String, Locale)&#125; returns null in order</span></span><br><span class="line"><span class="comment"> * to allow other potential &#123;<span class="doctag">@link</span> ViewResolver&#125; beans to resolve views.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ViewResolver <span class="title">mvcViewResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ViewResolverRegistry registry = <span class="keyword">new</span> ViewResolverRegistry(</span><br><span class="line">			mvcContentNegotiationManager(), <span class="keyword">this</span>.applicationContext);</span><br><span class="line">	configureViewResolvers(registry);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (registry.getViewResolvers().isEmpty() &amp;&amp; <span class="keyword">this</span>.applicationContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">		String[] names = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">				<span class="keyword">this</span>.applicationContext, ViewResolver.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">if</span> (names.length == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment">// 当只有一个元素的时候，说明只有它自身，没有其它的ViewResolver类型的Bean了</span></span><br><span class="line">			<span class="comment">// 这时候添加一个InternalResourceViewResolver</span></span><br><span class="line">			registry.getViewResolvers().add(<span class="keyword">new</span> InternalResourceViewResolver());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ViewResolverComposite composite = <span class="keyword">new</span> ViewResolverComposite();</span><br><span class="line">	composite.setOrder(registry.getOrder());</span><br><span class="line">	composite.setViewResolvers(registry.getViewResolvers());</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.applicationContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">		composite.setApplicationContext(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.servletContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">		composite.setServletContext(<span class="keyword">this</span>.servletContext);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> composite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从注释上可以知道，这个视图解析器（类型为<code>ViewResolverComposite</code>），是用来存放其它的<code>ViewResolver</code>的，然后当调用它的<code>ViewResolver</code>的resolveViewName方法时，它会遍历它存放的所有<code>ViewResolver</code>然后调用这些<code>ViewResolver</code>的resolveViewName方法（其实就是代理模式，它本身的resolveViewName方法其实只是调用其它的<code>ViewResolver</code>的resolveViewName方法，如果它里面存放的<code>ViewResolver</code>数量为0，这个方法将什么也不做）。</p>
<p>通过DUBUG设置断点查看有实际多少个<code>ViewResolver</code>类型的Bean，发现真的只有一个，就是上面的mvcViewResolver，具体类型为<code>ViewResolverComposite</code>，而它里面竟然存放一个<code>ViewResolver</code>，类型为<code>InternalResourceViewResolver</code>。</p>
<p><img src="https://i.imgur.com/CDGQmGy.png" alt="Imgur"></p>
<p>这个<code>InternalResourceViewResolver</code>是什么时候加进去的呢？？？回到配置mvcViewResolver这个Bean的代码，可以发现：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (names.length == <span class="number">1</span>) &#123;</span><br><span class="line">    registry.getViewResolver().add(<span class="keyword">new</span> InternalResourceViewResolver());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面创建了一个<code>InternalResourceViewResolver</code>实例并添加到了registry的ViewResolver列表中，registry是<code>ViewResolverRegistry</code>类型的，它里面有一个viewResolvers变量（类型为<code>List&lt;ViewResolver&gt;</code>），所以前面创建的<code>InternalResourceViewResolver</code>实例会被添加到viewResolvers变量里面，然后，<code>composite.setViewResolvers(registry.getViewResolvers());</code>这句会把这个实例添加到<code>ViewResolverComposite</code>实例的视图解析器列表中，也就是把<code>InternalResourceViewResolver</code>这个视图解析器存放到<code>ViewResolverComposite</code>这个视图解析器里面。</p>
<p>初始化<code>ViewResolver</code>的过程大概就是这样了，下面回到<code>DispatcherServlet</code>的resolveViewName方法，<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (ViewResolver viewResolver : <span class="keyword">this</span>.viewResolvers)</span><br></pre></td></tr></table></figure></p>
<p>所以上面的viewResolvers默认情况下应该只有一个元素，也就是<code>ViewResolverComposite</code>的实例，后面<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">View view = viewResolver.resolveViewName(viewName, locale);</span><br></pre></td></tr></table></figure></p>
<p>调用的resolveViewName方法也就是<code>ViewResolverComposite</code>的resolveViewName方法，然后代理给<code>InternalResourceViewResolver</code>执行，也就是说最终将执行<code>InternalResourceViewResolver</code>的resolveViewName方法。</p>
<p>去查看<code>InternalResourceViewResolver</code>的resolveViewName方法，发现方法不存在，因此这个方法应该是从父类继承的，这里很容易想到它应该是用了模板方法模式。一般跟踪之后，最终可以发现它会返回一个类型为<code>InternalResourceView</code>的视图对象（其实和前面分析过的也运用了模板方法模式的过程是类似的，一路跟踪下去就可以发现它的套路了）<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AbstractUrlBasedView <span class="title">buildView</span><span class="params">(String viewName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	InternalResourceView view = (InternalResourceView) <span class="keyword">super</span>.buildView(viewName);</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.alwaysInclude != <span class="keyword">null</span>) &#123;</span><br><span class="line">		view.setAlwaysInclude(<span class="keyword">this</span>.alwaysInclude);</span><br><span class="line">	&#125;</span><br><span class="line">	view.setPreventDispatchLoop(<span class="keyword">true</span>);</span><br><span class="line">	<span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以调用<code>DispatcherServlet</code>的resolveViewName方法我们最终可能得到一个类型为<code>InternalResourceView</code>得到视图（<code>View</code>）对象</p>
<h3 id="渲染视图"><a href="#渲染视图" class="headerlink" title="渲染视图"></a>渲染视图</h3><p>从上面可以知道我们得到了一个类型为<code>InternalResourceView</code>的视图对象，然后我们就可以调用<code>View</code>的render渲染视图了。<br>回到回到<code>DispatcherServlet</code>的render方法，在调用完resolveViewName方法后，如果返回的视图不为空，则<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">view.render(mv.getModelInternal(), request, response);</span><br></pre></td></tr></table></figure></p>
<p>调用返回的视图的render方法渲染视图，因为我们得到的是<code>InternalResourceView</code>对象，所以我们可以去看<code>InternalResourceView</code>的render方法，然而它并没有这个方法，说明这个方法是从父类继承的，又双叒叕是这个套路（模板方法模式）。经过一番跟踪，可以发现最终的渲染逻辑在<code>InternalResourceView</code>类的renderMergedOutputModel方法里面<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Render the internal resource given the specified model.</span></span><br><span class="line"><span class="comment"> * This includes setting the model as request attributes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">renderMergedOutputModel</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Expose the model object as request attributes.</span></span><br><span class="line">	exposeModelAsRequestAttributes(model, request);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Expose helpers as request attributes, if any.</span></span><br><span class="line">	exposeHelpers(request);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Determine the path for the request dispatcher.</span></span><br><span class="line">	String dispatcherPath = prepareForRendering(request, response);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Obtain a RequestDispatcher for the target resource (typically a JSP).</span></span><br><span class="line">	RequestDispatcher rd = getRequestDispatcher(request, dispatcherPath);</span><br><span class="line">	<span class="keyword">if</span> (rd == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"Could not get RequestDispatcher for ["</span> + getUrl() +</span><br><span class="line">				<span class="string">"]: Check that the corresponding file exists within your web application archive!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If already included or response already committed, perform include, else forward.</span></span><br><span class="line">	<span class="keyword">if</span> (useInclude(request, response)) &#123;</span><br><span class="line">		response.setContentType(getContentType());</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">"Including ["</span> + getUrl() + <span class="string">"]"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		rd.include(request, response);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Note: The forwarded resource is supposed to determine the content type itself.</span></span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">"Forwarding to ["</span> + getUrl() + <span class="string">"]"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		rd.forward(request, response);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然而它实际上只能渲染jsp视图，而且具体逻辑不是由它实现的，而是由Servlet容器（比如Tomcat容器默认配置了一个处理请求路径以<code>.jsp</code>或者<code>.jspx</code>结尾的请求的Servlet，名称叫jsp）实现的，它实际上把请求转发给Servlet容器中的其它Servlet，然后让其他Servlet来处理，而Servlet容器，比如Tomcat，默认只配置了一个处理jsp的Servlet和一个充当静态资源服务器的默认Servlet（这个默认Servlet的servletMapping已经被移除了，因为我们配置了DispatcherServlet的值为<code>/</code>的时候会覆盖它的servletMapping)，所以默认情况下只能渲染jsp视图。</p>
<h2 id="调用拦截器的afterCompletion方法"><a href="#调用拦截器的afterCompletion方法" class="headerlink" title="调用拦截器的afterCompletion方法"></a>调用拦截器的afterCompletion方法</h2><p>渲染完视图之后，还没有结束，还要执行拦截器的afterCompletion方法（所以拦截器的afterCompletion方法是在视图渲染完成之后执行的）。回到<code>DispatcherServlet</code>的processDispatchResult方法，可以看到在最后，会调用<code>HandlerExecutionChain</code>的triggerAfterCompletion来执行拦截器的afterCompletion方法。查看<code>HandlerExecutionChain</code>的triggerAfterCompletion方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">triggerAfterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, @Nullable Exception ex)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">	HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">	<span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">		<span class="comment">// 这里将从最后一个执行的拦截器的索引开始从后完前执行</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.interceptorIndex; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			HandlerInterceptor interceptor = interceptors[i];</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				interceptor.afterCompletion(request, response, <span class="keyword">this</span>.handler, ex);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Throwable ex2) &#123;</span><br><span class="line">				logger.error(<span class="string">"HandlerInterceptor.afterCompletion threw exception"</span>, ex2);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以发现，这里将从<code>this.interceptorIndex</code>位置开始，从后往前执行相应的拦截器的afterCompletion。为什么要这样执行，而不是从0到最后一个或者直接从最后一个到0？这是因为，执行拦截器的preHandle方法的时候，如果返回了false，后面的拦截器的preHandle是不会执行的，因为后面的拦截器的afterCompletion也不应该最后执行。所以索引是从<code>this.interceptorIndex</code>开始的，这个索引的位置为最后一个执行的拦截器的位置。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>SpringMVC用<code>DispatcherServlet</code>来分发请求，大概分为以下几个步骤：</p>
<ol>
<li><p>检查request是否包含Multipart，如果是则调用<code>MultipartResolver</code>的resolveMultipart方法将请求转换成<code>MultipartHttpServletRequest</code>类型</p>
</li>
<li><p>调用<code>HandlerMapping</code>的getHandler方法获取<code>HandlerExecutionChain</code>，HandlerExecutionChain包含了最匹配的handler和所有匹配的拦截器（<code>HandlerInterceptor</code>）</p>
</li>
<li><p>调用<code>HandlerAdapter</code>的supports方法获得支持调用本次请求匹配到的handler的<code>HandlerAdapter</code></p>
</li>
<li><p>调用<code>HandlerExecutionChain</code>的applyPreHandle方法执行拦截器的preHandle方法</p>
</li>
<li><p>调用<code>HandlerAdapter</code>的handle方法调用handler，将返回<code>ModelAndView</code></p>
</li>
<li><p>调用<code>RequestToViewNameTranslator</code>的getViewName方法将请求路径映射到视图名称，并设置到<code>ModelAndView</code>中</p>
</li>
<li><p>调用<code>HandlerExecutionChain</code>的applyPostHandle方法执行拦截器的postHandle方法</p>
</li>
<li><p>调用<code>LocaleResolver</code>的resolveLocale方法解析请求对应的地区，并绑定到<code>HttpServletResponse</code>的属性中</p>
</li>
<li><p>调用<code>ViewResolver</code>的resolveViewName方法解析视图，将返回<code>View</code>对象</p>
</li>
<li><p>调用<code>View</code>的render方法渲染视图</p>
</li>
<li><p>调用<code>HandlerExecutionChain</code>的triggerAfterCompletion方法来执行拦截器的afterCompletion方法</p>
</li>
</ol>
<p>大概就是这样一个过程（异常处理等过程没有写出来）。<br>还有很多细节需要研究，个人感觉最复杂繁琐的就是上面的第2步了，在获取<code>HandlerExecutionChain</code>之前，需要获取请求匹配的handler，而这个handler（假设是我们写的Controller里面的方法）可能有很多个参数，参数可以有很多类型，需要根据<code>HttpServletRequest</code>的信息解析出需要的参数的值，而这需要很多<code>HandlerMethodArgumentResolver</code>来解析，所以这些参数的解析过程，还是比较复杂的。</p>

                <hr>
                

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2018/12/23/spring-boot自动配置原理/" data-toggle="tooltip" data-placement="top"
                           title="spring-boot自动配置原理">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2018/12/21/SpringMVC-DispatcherServlet的创建流程/" data-toggle="tooltip" data-placement="top"
                           title="SpringMVC DispatcherServlet的创建流程">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                

                


                <!--加入新的评论系统-->
                
                <!-- 来必力City版安装代码 -->
                <div id="lv-container" data-id="city" data-uid="MTAyMC8zODUyNi8xNTA1NA==">
                    <script type="text/javascript">
                        (function(d, s) {
                            var j, e = d.getElementsByTagName(s)[0];

                            if (typeof LivereTower === 'function') { return; }

                            j = d.createElement(s);
                            j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                            j.async = true;

                            e.parentNode.insertBefore(j, e);
                        })(document, 'script');
                    </script>
                    <noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
                </div>
                <!-- City版安装代码已完成 -->
                
            </div>

            <div class="hidden-xs col-sm-3 toc-col">
                <div class="toc-wrap">
                    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#DispatcherServlet的匹配规则"><span class="toc-text">DispatcherServlet的匹配规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#将各种resolver和属性绑定到request"><span class="toc-text">将各种resolver和属性绑定到request</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解析Multipart"><span class="toc-text">解析Multipart</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#根据请求路径找到匹配的handler"><span class="toc-text">根据请求路径找到匹配的handler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#获取对应的HandlerAdapter"><span class="toc-text">获取对应的HandlerAdapter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#调用拦截器的preHandle方法"><span class="toc-text">调用拦截器的preHandle方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#调用handler"><span class="toc-text">调用handler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#调用拦截器的postHandle方法"><span class="toc-text">调用拦截器的postHandle方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异常处理"><span class="toc-text">异常处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解析和渲染视图"><span class="toc-text">解析和渲染视图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#解析视图"><span class="toc-text">解析视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#渲染视图"><span class="toc-text">渲染视图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#调用拦截器的afterCompletion方法"><span class="toc-text">调用拦截器的afterCompletion方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol>
                </div>
            </div>
        </div>

        <div class="row">
            <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5 class="text-center">
                        <a href="/Tags/">FEATURED TAGS</a>
                    </h5>
                    <div class="tags">
                        
                        <a class="tag" href="/Tags/#SpringMVC"
                           title="SpringMVC">SpringMVC</a>
                        
                        <a class="tag" href="/Tags/#Web"
                           title="Web">Web</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <div style="margin-top: 20px;">
                    <h5 class="text-center">FRIENDS</h5>
                    <ul class="list-inline text-center">
                        
                        <li><a href="https://echi.me">echisan</a></li>
                        
                    </ul>
                </div>
                
            </div>
        </div>

    </div>
</article>







<!-- Footer -->
<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <br>
                <ul class="list-inline text-center">
                
                
                    <li>
                        <a target="_blank" href="https://twitter.com/plentymorea">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/plentymore">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; PLTM 2021
                    <br>
                    <span id="busuanzi_container_site_pv" style="font-size: 12px;">PV: <span id="busuanzi_value_site_pv"></span> Times</span>
                    <br>
                    <br>
                    Theme by <a href="https://github.com/Haojen/hexo-theme-Anisina">Haojen Ma</a>
                </p>

            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/blog.js"></script>

<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://plentymore.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>

<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-123175280-1';
    var _gaDomain = 'plentymore.github.io';
    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>


<!-- Baidu Tongji -->


<!-- swiftype -->
<!-- <script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','','2.0.0');
</script> -->

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<!--wechat title img-->
<img class="wechat-title-img" src="https://avatars3.githubusercontent.com/u/30522768?s=400&amp;u=a2ce54d7c63789391a0ba32b17792b7a21d64fbb&amp;v=4">
</body>

</html>
