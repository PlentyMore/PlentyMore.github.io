<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="BLOG">
    <meta name="keyword" content="pltm">
    <meta name="theme-color" content="#600090">
    <meta name="msapplication-navbutton-color" content="#600090">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="#600090">
    <!-- google-site-verification -->
    <meta name="google-site-verification" content="fgG59EBWTLiWni3UcgCPhkEPiVDNCnLeaocoTWjctOg" />
    <link rel="shortcut icon" href="/images/favicon.png">
    <link rel="alternate" type="application/atom+xml" title="PLTM" href="/atom.xml">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.css">
    <title>
        
        Spring IoC原理｜PTLM blog
        
    </title>

    <link rel="canonical" href="https://plentymore.github.io/2018/12/24/Spring-IoC原理/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/blog-style.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">
    <!-- Google AdSense -->
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
             google_ad_client: "ca-pub-1771277850135880",
             enable_page_level_ads: true
          });
    </script>
</head>

<style>

    header.intro-header {
        background-image: url('/images/3.jpg')
    }
</style>
<!-- hack iOS CSS :active style -->
<body ontouchstart="" class="animated fadeIn">
<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top " id="nav-top" data-ispost = "true" data-istags="false
" data-ishome = "false" >
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand animated pulse" href="/">
                <span class="brand-logo">
                    PLTM
                </span>
                's Blog
            </a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <!-- /.navbar-collapse -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
					
                    
                        
							
                        <li>
                            <a href="/Tags/">Tags</a>
                        </li>
							
						
                    
                        
							
								
							
						
                    
					
					
						<li>
							<a href="/about">About</a>
						</li>
					
                </ul>
            </div>
        </div>
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
//    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>

<!-- Main Content -->

<!--only post-->


<img class="wechat-title-img"
     src="/images/3.jpg">


<style>
    
    header.intro-header {
        background-image: url('/images/3.jpg')
    }

    
</style>

<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <div class="post-heading">
                    <h1>Spring IoC原理</h1>
                    
                    <span class="meta">
                         作者 plentymore
                        <span>
                          日期 2018-12-24
                         </span>
                    </span>
                    <div class="tags text-center">
                        
                        <a class="tag" href="/Tags/#Spring"
                           title="Spring">Spring</a>
                        
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="post-title-haojen">
        <span>
            Spring IoC原理
        </span>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <!-- Post Container -->
            <div class="col-lg-8 col-lg-offset-1 col-sm-9 post-container">
                <p>Spring的核心是它的IoC（控制反转）容器和AOP（面向切面编程），Spring与其它类库的整合（比如Spring事务，Spring Data JDBC等）大部分都是在建立在这两个功能的基础上的。在使用Spring的IoC容器的时候，在类上面加几个注解就可以了，用起来非常的简单，具体的原理我只知道一点点（比如<code>BeanFactory</code>可以访问IoC容器，可以用它来获取创建好的Bean实例，创建好的Bean实例（仅限Scope为Singleton的）放在一个<code>Map</code>中，根据<code>BeanDefinition</code>创建Bean实例之类的），由于只是一知半解，在读Spring Boot源码的时候显得有点吃力，所以就跑回来研究Spring最基础的IoC容器和AOP了。</p>
<p>在读源码之前，我觉得首先最好要非常熟悉怎样使用Spring，具体就是怎样用它来为我们注入依赖（根据类型注入，根据名称注入，构造器注入等），有哪几种配置方式（xml配置，java注解配置，java注解 + xml配置等），只有非常了解它可以做什么，并能够熟练地使用它来做这些事情，才能更好地理解源码。要熟悉怎样使用，可以直接看Spring的Reference Doc，没有人比它自己更了解自己，看官方文档是最好的选择。每一个Spring项目基本上都配有相应的文档，项目和文档会一起更新。除了文档之外，还会有API Doc，看源码的时候，可以打开相应的API Doc，里面可以很清楚地看到源码的组织结构，每一个package包含哪些类和接口，和它们的主要作用，都可以看的一清二楚，还可以查看类和接口上面的注释（有时候在IDE里面看源码的时候，注释和代码混在一起，想要快速查看某个类有哪些方法会比较麻烦，这时候看API Doc就很方便了，因为API Doc上面只有方法签名和注释，没有具体实现的代码）。</p>
<p>一般读源码的时候，我会DUBUG设置断点根据程序的执行流程跟着去看。<br>下面有一个很简单的程序，具体功能是使用基于Java注解的方式配置一个Bean，然后用<code>ApplicationContext</code>来获取这个Bean的实例<br><code>Bs.java</code><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(Bs.class);</span><br><span class="line">        MyBean mb = ctx.getBean(MyBean.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Config.java</code><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyBean <span class="title">myBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>MyBean.java</code><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一个有三个类文件，Bs.java，Config.java和MyBean.java<br>这个程序非常简单，主要是想利用它来DUBUG设置断点，看一下具体的执行流程</p>
<p>在<code>AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(Bs.class);</code>这行设置断点，跟踪<code>AnnotationConfigApplicationContext</code>的创建和初始化过程。首先来看一下类的继承关系<br><img src="https://i.imgur.com/FJATQ07.png" alt="Imgur"></p>
<p>图片里面很多类和接口，本来想删掉一些让继承关系看起来更清晰的，但是感觉每一个都很必要，删掉之后总会漏掉什么</p>
<h2 id="几个重要的接口"><a href="#几个重要的接口" class="headerlink" title="几个重要的接口"></a>几个重要的接口</h2><p>只列举出比较常用和重要的接口</p>
<h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><p><a href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/factory/BeanFactory.html" target="_blank" rel="noopener">BeanFactory</a>是用来访问Spring IoC容器的顶层接口，可以用它获取容器里面存放的Bean，一般我们通常不使用它来直接获取Bean（<code>MyBean mb = beanFactory.getBean(MyBean.class)</code>），而是通过依赖注入的方式（通过构造器，或者setter方法来注入相应的依赖）。实现这个接口的类，里面通常存放有很多的<code>BeanDefinition</code>，通常存放在一个<code>Map</code>里面，key为<code>BeanDefinition</code>对应的类的全限定名，value为<code>BeanDefinition</code>实例，<code>BeanFactory</code>可以从不同的配置源（比如xml文件，Java注解等）加载这些<code>BeanDefinition</code>。<code>BeanFactory</code>根据<code>BeanDefinition</code>来创建Bean的实例。主要的方法是getBean方法</p>
<h4 id="ListableBeanFactory"><a href="#ListableBeanFactory" class="headerlink" title="ListableBeanFactory"></a>ListableBeanFactory</h4><p><a href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/factory/ListableBeanFactory.html" target="_blank" rel="noopener">ListableBeanFactory</a>拓展了<code>BeanFactory</code>接口，它将预先创建好所有的Bean的实例，而不是要使用某个Bean的时候才创建。</p>
<h4 id="HierarchicalBeanFactory"><a href="#HierarchicalBeanFactory" class="headerlink" title="HierarchicalBeanFactory"></a>HierarchicalBeanFactory</h4><p><a href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/factory/HierarchicalBeanFactory.html" target="_blank" rel="noopener">HierarchicalBeanFactory</a>是分级的<code>BeanFactory</code>，比如分成父级和子级，调用containsLocalBean方法查找Bean的时候只在当前级别查找，当前级别Bean不存在则返回空，不会向父级查找</p>
<h4 id="AutowireCapableBeanFactory"><a href="#AutowireCapableBeanFactory" class="headerlink" title="AutowireCapableBeanFactory"></a>AutowireCapableBeanFactory</h4><p><a href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/factory/config/AutowireCapableBeanFactory.html" target="_blank" rel="noopener">AutowireCapableBeanFactory</a>提供自动装配能力（自动地根据Bean名称或者类型配置好依赖，无需手动配置）的<code>BeanFactory</code>，它是实现依赖注入的关键接口。</p>
<h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><p><a href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/javadoc-api/org/springframework/context/ApplicationContext.html" target="_blank" rel="noopener">ApplicationContext</a>拥有<code>BeanFactory</code>的所有功能（在<code>ApplicationContext</code>的实现类里面可以看到有一个<code>BeanFactory</code>实现类的成员），还提供了很多额外的功能（它实现了很多其它接口），比如加载文件资源(实现了<code>ResourceLoader</code>接口)，发布事件（实现了<code>ApplicationEventPublisher</code>接口），国际化（指多语言支持，实现了<code>MessageSource</code>接口）等，它同时继承了<code>ListableBeanFactory</code>和<code>HierarchicalBeanFactory</code>接口，所以它是将所有的Bean的实例预先创建好的，而且还可以分级，比如一个rootApplicationContext，然后多个subApplicationContext。</p>
<h4 id="ConfigurableApplicationContext"><a href="#ConfigurableApplicationContext" class="headerlink" title="ConfigurableApplicationContext"></a>ConfigurableApplicationContext</h4><p><a href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/javadoc-api/org/springframework/context/ConfigurableApplicationContext.html" target="_blank" rel="noopener">ConfigurableApplicationContext</a>是可配置的<code>ApplicationContext</code>，能够在<code>ApplicationContext</code>被创建之后继续配置配置它，比如添加<code>BeanFactoryPostProcessor</code>，<code>ApplicationListener</code>等</p>
<h3 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h3><p><a href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/factory/config/BeanDefinition.html" target="_blank" rel="noopener">BeanDefinition</a>用来描述一个Bean，比如这个Bean对应的类名是什么，是不是要延迟加载（要使用的时候才创建Bean的实例），是不是单例，能不能用于自动装配，它的依赖有哪些等</p>
<h3 id="BeanDefinitionRegistry"><a href="#BeanDefinitionRegistry" class="headerlink" title="BeanDefinitionRegistry"></a>BeanDefinitionRegistry</h3><p><a href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/factory/support/BeanDefinitionRegistry.html" target="_blank" rel="noopener">BeanDefinitionRegistry</a>相当于一个存放<code>BeanDefinition</code>的仓库，它提供了注册、移除、获取<code>BeanDefinition</code>的方法（其实就是把<code>BeanDefinition</code>放进<code>Map</code>，从<code>Map</code>移除，从<code>Map</code>查找），这个接口一般由bean Definition readers实现，因为bean Definition readers要从配置文件解析<code>BeanDefinition</code>然后存起来</p>
<h3 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h3><p><a href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/factory/config/BeanFactoryPostProcessor.html" target="_blank" rel="noopener">BeanFactoryPostProcessor</a>接口是Spring IoC容器的<a href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/core.html#beans-factory-extension-factory-postprocessors" target="_blank" rel="noopener">拓展点</a>之一，实现了这个接口类配置成Bean后能够被<code>ApplicationContext</code>自动检测到（后面会讲到，其实就是用<code>BeanFactory</code>获取所有实现了这个接口的Bean）。Spring IoC容器使用<code>BeanFactoryPostProcessor</code>来读取Bean配置元数据，也就是<code>BeanDefinition</code>，可以在实例化Bean前对<code>BeanDefinition</code>作任意的修改。<br>该接口仅有这样一个方法<br><code>void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException</code>你可以实现这个接口，然后在这个方法里面修改<code>BeanFactory</code>存储的<code>BeanDefinition</code>，然后把你实现的<code>BeanFactoryPostProcessor</code>注册到IoC容器中，然后就能够实现自定义配置<code>BeanDefinition</code>了。可以注册多个<code>BeanFactoryPostProcessor</code>到容器，最好实现<code>Order</code>接口指定执行的优先级，优先级高的<code>BeanFactoryPostProcessor</code>会先执行。</p>
<h3 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h3><p><a href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/factory/config/BeanPostProcessor.html" target="_blank" rel="noopener">BeanPostProcessor</a>接口是Spring IoC容器的<a href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/core.html#beans-factory-extension-bpp" target="_blank" rel="noopener">另一个拓展点</a>，它和<code>BeanFactoryPostProcessor</code>类似，不同之处在于，<code>BeanFactoryPostProcessor</code>是处理<code>BeanDefinition</code>的，而<code>BeanPostProcessor</code>是处理实例化的Bean的（实际上<code>BeanFactoryPostProcessor</code>不仅仅可以处理BeanDefinition，它甚至可以实例化Bean，因为它的方法参数是<code>beanFactory</code>，因此它能做的事情远远不止这些，但是官方不建议用它来做其他事情），实现<code>BeanPostProcessor</code>接口，你可以自定义Bean实例化的逻辑，还有Bean的依赖解析逻辑（你可以用自定义的逻辑覆盖默认的逻辑）。该接口的其它方面和<code>BeanFactoryPostProcessor</code>类似，比如都要注册到容器，能被<code>ApplicationContext</code>自动检测到，可以注册多个实例等</p>
<h2 id="创建ApplicationContext"><a href="#创建ApplicationContext" class="headerlink" title="创建ApplicationContext"></a>创建ApplicationContext</h2><p>回到<code>AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(Bs.class)</code>这行代码，我在这里设置了一个断点，以便观察它的创建流程。<code>AnnotationConfigApplicationContext</code>是<code>ApplicationContext</code>的一个具体实现类，<code>ApplicationContext</code>的具体实现类有如下几个（除了接口其他的类都是具体的实现类）<br><img src="https://i.imgur.com/TJ2pCSo.png" alt="Imgur"></p>
<p>从上面的图中可以看到<code>AnnotationConfigApplicationContext</code>是<code>GenericApplicationContext</code>的子类，<code>AnnotationConfigApplicationContext</code>被调用的构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... annotatedClasses)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>();</span><br><span class="line">	register(annotatedClasses);</span><br><span class="line">	refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的图主要用来看会调用哪几个父类的构造器和代码块等</p>
<p><img src="https://i.imgur.com/3yvk42M.png" alt="Imgur"></p>
<p>从图中可以看到，有三个父类（其他的都是接口，没有构造器）</p>
<h3 id="this"><a href="#this" class="headerlink" title="this.()"></a>this.()</h3><p>将调用这个构造函数创建<code>ApplicationContext</code>，首先调用了<code>AnnotationConfigApplicationContext</code>类的无参构造器，然后调用register方法，最后调用refresh方法，由于它还有父类，因此父类的构造方法或者父类的静态代码块先执行，它的直接父类<code>GenericApplicationContext</code>的构造方法如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">GenericApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到它创建了一个<code>DefaultListableBeanFactory</code>，这是<code>BeanFactory</code>的一种实现，后面将会用到这个<code>BeanFactory</code>。<br><code>GenericApplicationContext</code>的直接父类为<code>AbstractApplicationContext</code>，它里面有一段静态代码块：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">	<span class="comment">// Eagerly load the ContextClosedEvent class to avoid weird classloader issues</span></span><br><span class="line">	<span class="comment">// on application shutdown in WebLogic 8.1. (Reported by Dustin Woods.)</span></span><br><span class="line">	ContextClosedEvent.class.getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段静态代码块将会最在它的父类的静态代码块执行之后再执行（静态代码块的执行发生在代码块和构造器之前，所以静态代码块会比构造器先执行），作用是把<code>ContextClosedEvent</code>类尽快地加载进来避免一些迷之加载器bug</p>
<p>由于<code>AbstractApplicationContext</code>还有一个父类<code>DefaultResourceLoader</code>，所以它的构造器将会在<code>DefaultResourceLoader</code>的构造器执行之后再执行，<code>DefaultResourceLoader</code>里面有静态代码块，主要做的事情是将Java基本类型映射到Java包装类（比如int.class -&gt; Integer.class具体可以去看代码）。它的构造器如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultResourceLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取默认的类加载器，并设置为DefaultResourceLoader的类加载器</span></span><br><span class="line">	<span class="keyword">this</span>.classLoader = ClassUtils.getDefaultClassLoader();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再回到<code>AbstractApplicationContext</code>，它的无参构造器如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new AbstractApplicationContext with no parent.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.resourcePatternResolver = getResourcePatternResolver();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> ResourcePatternResolver <span class="title">getResourcePatternResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> PathMatchingResourcePatternResolver(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建了一个<code>PathMatchingResourcePatternResolver</code>实例，用于根据路径解析出路径里面的资源。</p>
<p>调用<code>AnnotationConfigApplicationContext</code>的构造参数的时候，具体的执行顺序为：</p>
<ol>
<li><code>AbstractApplicationContext</code>的静态代码块</li>
<li><code>AbstractApplicationContext</code>的无参数构造器（创建了<code>PathMatchingResourcePatternResolver</code>的实例）</li>
<li><code>GenericApplicationContext</code>的无参构造器（创建了<code>DefaultListableBeanFactory</code>的实例）</li>
<li><code>AnnotationConfigApplicationContext</code>的参数类型为<code>Class&lt;?&gt;</code>的构造器（调用了自身的无参构造器，调用了register和refresh方法）</li>
</ol>
<p><code>AnnotationConfigApplicationContext</code>的无参构造器如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建了<code>AnnotatedBeanDefinitionReader</code>和<code>ClassPathBeanDefinitionScanner</code>的实例，前者用于读取<code>BeanDefinition</code>的配置文件信息（这里是基于注解的配置），后者用于扫描<code>BeanDefinition</code>的配置文件信息（这里也是基于注解的配置）</p>
<p>重点留意<code>AnnotatedBeanDefinitionReader</code>，创建它的实例的时候，会注册很多的<code>BeanFactoryPostProcessor</code>和<code>BeanFactoryPostProcessor</code>（后面将统称为PostProcessor），用于读取<code>BeanDefinition</code>的配置文件信息和创建Bean，它的构造方法如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotatedBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>(registry, getOrCreateEnvironment(registry));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotatedBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry, Environment environment)</span> </span>&#123;</span><br><span class="line">	Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line">	Assert.notNull(environment, <span class="string">"Environment must not be null"</span>);</span><br><span class="line">	<span class="keyword">this</span>.registry = registry;</span><br><span class="line">	<span class="keyword">this</span>.conditionEvaluator = <span class="keyword">new</span> ConditionEvaluator(registry, environment, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这个方法将会注册需要的PostProcessor</span></span><br><span class="line">	AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="keyword">this</span>.registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>重点看<code>AnnotationConfigUtils</code>的registerAnnotationConfigProcessors方法，它将会注册很多的PostProcessor<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerAnnotationConfigProcessors</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">	registerAnnotationConfigProcessors(registry, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它调用了另一个registerAnnotationConfigProcessors方法（方法重载）<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register all relevant annotation post processors in the given registry.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registry the registry to operate on</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> source the configuration source element (already extracted)</span></span><br><span class="line"><span class="comment"> * that this registration was triggered from. May be &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a Set of BeanDefinitionHolders, containing all bean definitions</span></span><br><span class="line"><span class="comment"> * that have actually been registered by this call</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">registerAnnotationConfigProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		BeanDefinitionRegistry registry, @Nullable Object source)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);</span><br><span class="line">	<span class="keyword">if</span> (beanFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(beanFactory.getDependencyComparator() <span class="keyword">instanceof</span> AnnotationAwareOrderComparator)) &#123;</span><br><span class="line">			beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!(beanFactory.getAutowireCandidateResolver() <span class="keyword">instanceof</span> ContextAnnotationAutowireCandidateResolver)) &#123;</span><br><span class="line">			beanFactory.setAutowireCandidateResolver(<span class="keyword">new</span> ContextAnnotationAutowireCandidateResolver());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 用BeanDefinitionHolder把PostProcessor的BeanDefinition存起来</span></span><br><span class="line">	Set&lt;BeanDefinitionHolder&gt; beanDefs = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">		<span class="comment">// 将注册ConfigurationClassPostProcessor</span></span><br><span class="line">		RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(ConfigurationClassPostProcessor.class);</span><br><span class="line">		def.setSource(source);</span><br><span class="line">		beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">		<span class="comment">// 将注册AutowiredAnnotationBeanPostProcessor</span></span><br><span class="line">		RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class="line">		def.setSource(source);</span><br><span class="line">		beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.</span></span><br><span class="line">	<span class="keyword">if</span> (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">		<span class="comment">// 将注册CommonAnnotationBeanPostProcessor</span></span><br><span class="line">		RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);</span><br><span class="line">		def.setSource(source);</span><br><span class="line">		beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.</span></span><br><span class="line">	<span class="keyword">if</span> (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">		<span class="comment">// 将注册PersistenceAnnotationBeanPostProcessor</span></span><br><span class="line">		RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,</span><br><span class="line">					AnnotationConfigUtils.class.getClassLoader()));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">					<span class="string">"Cannot load optional framework class: "</span> + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		def.setSource(source);</span><br><span class="line">		beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">		<span class="comment">// 将注册EventListenerMethodProcessor</span></span><br><span class="line">		RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(EventListenerMethodProcessor.class);</span><br><span class="line">		def.setSource(source);</span><br><span class="line">		beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) &#123;</span><br><span class="line">		<span class="comment">// 将注册DefaultEventListenerFactory</span></span><br><span class="line">		RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(DefaultEventListenerFactory.class);</span><br><span class="line">		def.setSource(source);</span><br><span class="line">		beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> beanDefs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>registerAnnotationConfigProcessors主要注册了如下的几个PostProcessor</p>
<ol>
<li><p><code>ConfigurationClassPostProcessor</code>，注册的名称为”org.springframework.context.annotation.internalConfigurationAnnotationProcessor”，用于处理被<code>@Configuration</code>注解标注的类，也就是从被<code>@Configuration</code>标注的类里面读取<code>BeanDefinition</code>配置信息，这个PostProcessor会在以下的情况被注册：xml配置文件里面有<a href="context:annotation-config/" target="_blank" rel="noopener">context:annotation-config/</a>或者<a href="context:component-scan/" target="_blank" rel="noopener">context:component-scan/</a>，或者类上面有<code>@ComponentScan</code>注解</p>
</li>
<li><p><code>AutowiredAnnotationBeanPostProcessor</code>，注册的名称为”org.springframework.context.annotation.internalAutowiredAnnotationProcessor”，用于实现依赖属性的自动装配（根据名称或者类型自动注入合适的属性），能够处理<code>@Autowire</code>、<code>@Value</code>和<code>@Inject</code>注解，这个PostProcessor会在以下的情况被注册：和上面的<code>ConfigurationClassPostProcessor</code>一样。需要注意的是，xml手动指定的属性会覆盖掉自动装配注入的属性，因为自动装配发生在xml之前</p>
</li>
<li><p><code>CommonAnnotationBeanPostProcessor</code>，注册的名称为”org.springframework.context.annotation.internalCommonAnnotationProcessor”，用于支持处理JSR-250的标准注解，比如<a href="mailto:`@javax.annotation.PostConstruct" target="_blank" rel="noopener">`@javax.annotation.PostConstruct</a><code>，</code>@javax.annotation.PreDestroy<code>，</code>javax.annotation.Resource<code>。这个PostProcessor会在以下的情况被注册：JSR-250的jar包在classpath中（代码上通过</code>ClassUtils.isPresent(“javax.annotation.Resource”, classLoader)`这句代码检测的）</p>
</li>
<li><p><code>org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor</code>（特意用了全限定名，因为它在orm包里面），注册的名称为”org.springframework.context.annotation.internalPersistenceAnnotationProcessor”，主要用于处理 <code>@PersistenceUnit</code>和<code>@PersistenceContext</code>注解，以便注入相应的<code>EntityManagerFactory</code>和<code>EntityManager</code>（这些东西要用过Spring集成的Hibernate JPA才懂）。这个PostProcessor会在以下的情况被注册：SpringFramework ORM模块和JPA的API模块在classpath中（代码上通过<code>ClassUtils.isPresent(&quot;javax.persistence.EntityManagerFactory&quot;, classLoader) &amp;&amp; ClassUtils.isPresent(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, classLoader)</code>进行检测）</p>
</li>
<li><p><code>EventListenerMethodProcessor</code>，注册的名称为”org.springframework.context.event.internalEventListenerProcessor”，主要用于处理<code>@EventListener</code>注解。这个PostProcessor会在以下的情况被注册：和<code>ConfigurationClassPostProcessor</code>一样。</p>
</li>
<li><p><code>DefaultEventListenerFactory</code>，注册的名称为”org.springframework.context.event.internalEventListenerFactory”，主要用于为被<code>@EventListener</code>标注的方法创建<code>ApplicationListener</code>实例，<code>DefaultEventListenerFactory</code>的Bean创建后将会被设置到<code>EventListenerMethodProcessor</code>的eventListenerFactories属性中，被<code>EventListenerMethodProcessor</code>使用。这个PostProcessor会在以下的情况被注册：和<code>ConfigurationClassPostProcessor</code>一样。</p>
</li>
</ol>
<h3 id="register-Class-lt-gt-…-annotatedClasses"><a href="#register-Class-lt-gt-…-annotatedClasses" class="headerlink" title="register(Class&lt;?&gt;… annotatedClasses)"></a>register(Class&lt;?&gt;… annotatedClasses)</h3><p>上面的PostProcessor注册好后，<code>AnnotatedBeanDefinitionReader</code>的实例也将创建完成，然后创建完<code>ClassPathBeanDefinitionScanner</code>的实例之后，就要执行<code>AnnotationConfigApplicationContext</code>的register方法了<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Class&lt;?&gt;... annotatedClasses)</span> </span>&#123;</span><br><span class="line">	Assert.notEmpty(annotatedClasses, <span class="string">"At least one annotated class must be specified"</span>);</span><br><span class="line">	<span class="comment">// 我传入的annotatedClasses为Bs.class</span></span><br><span class="line">	<span class="keyword">this</span>.reader.register(annotatedClasses);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到实际上调用的是<code>AnnotatedBeanDefinitionReader</code>的register方法，这个方法的具体实现如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void register(Class&lt;?&gt;... annotatedClasses) &#123;</span><br><span class="line">	for (Class&lt;?&gt; annotatedClass : annotatedClasses) &#123;</span><br><span class="line">		registerBean(annotatedClass);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>AnnotatedBeanDefinitionReader</code>的register方法将遍历传入的annotatedClasses，然后调用registerBean方法，将annotatedClass传入参数（我只传入了一个Bs.class，因此这里实际调用将会只执行一次registerBean(Bs.class)）<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(Class&lt;?&gt; annotatedClass)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 实际调用将会是doRegisterBean(Bs.class)</span></span><br><span class="line">	doRegisterBean(annotatedClass, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到又调用了另一个方法，<code>AnnotatedBeanDefinitionReader</code>的doRegisterBean方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">doRegisterBean</span><span class="params">(Class&lt;T&gt; annotatedClass, @Nullable Supplier&lt;T&gt; instanceSupplier, @Nullable String name,</span></span></span><br><span class="line"><span class="function"><span class="params">		@Nullable Class&lt;? extends Annotation&gt;[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	AnnotatedGenericBeanDefinition abd = <span class="keyword">new</span> AnnotatedGenericBeanDefinition(annotatedClass);</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	abd.setInstanceSupplier(instanceSupplier);</span><br><span class="line">	ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">	abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line">	String beanName = (name != <span class="keyword">null</span> ? name : <span class="keyword">this</span>.beanNameGenerator.generateBeanName(abd, <span class="keyword">this</span>.registry));</span><br><span class="line"></span><br><span class="line">	AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line">	<span class="keyword">if</span> (qualifiers != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (Class&lt;? extends Annotation&gt; qualifier : qualifiers) &#123;</span><br><span class="line">			<span class="keyword">if</span> (Primary.class == qualifier) &#123;</span><br><span class="line">				abd.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (Lazy.class == qualifier) &#123;</span><br><span class="line">				abd.setLazyInit(<span class="keyword">true</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				abd.addQualifier(<span class="keyword">new</span> AutowireCandidateQualifier(qualifier));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (BeanDefinitionCustomizer customizer : definitionCustomizers) &#123;</span><br><span class="line">		customizer.customize(abd);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(abd, beanName);</span><br><span class="line">	definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">	BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>doRegisterBean方法里面终于是实际的逻辑了，主要步骤如下：</p>
<ol>
<li><p>调用<code>BeanNameGenerator</code>的generateBeanName方法生成Bean名称（传统是第一个字母小写的驼峰式），由于我传入的类叫做<code>Bs.class</code>，所以生成的名称将会是”bs”，具体可以看<code>BeanNameGenerator</code>的实现（这里用的具体实现类是<code>AnnotationBeanNameGenerator</code>）</p>
</li>
<li><p>调用<code>AnnotationConfigUtils</code>的processCommonDefinitionAnnotations方法处理<code>BeanDefinition</code>对应的类上面的注解，下面看看它的具体实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processCommonDefinitionAnnotations</span><span class="params">(AnnotatedBeanDefinition abd)</span> </span>&#123;</span><br><span class="line">	processCommonDefinitionAnnotations(abd, abd.getMetadata());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processCommonDefinitionAnnotations</span><span class="params">(AnnotatedBeanDefinition abd, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 看看有没有@Lazy注解</span></span><br><span class="line">	AnnotationAttributes lazy = attributesFor(metadata, Lazy.class);</span><br><span class="line">	<span class="keyword">if</span> (lazy != <span class="keyword">null</span>) &#123;</span><br><span class="line">		abd.setLazyInit(lazy.getBoolean(<span class="string">"value"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (abd.getMetadata() != metadata) &#123;</span><br><span class="line">		lazy = attributesFor(abd.getMetadata(), Lazy.class);</span><br><span class="line">		<span class="keyword">if</span> (lazy != <span class="keyword">null</span>) &#123;</span><br><span class="line">			abd.setLazyInit(lazy.getBoolean(<span class="string">"value"</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 看看有没有@Primary注解</span></span><br><span class="line">	<span class="keyword">if</span> (metadata.isAnnotated(Primary.class.getName())) &#123;</span><br><span class="line">		abd.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 看看有没有@DependsOn注解</span></span><br><span class="line">	AnnotationAttributes dependsOn = attributesFor(metadata, DependsOn.class);</span><br><span class="line">	<span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">		abd.setDependsOn(dependsOn.getStringArray(<span class="string">"value"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">       <span class="comment">// 看看有没有@Role注解</span></span><br><span class="line">	AnnotationAttributes role = attributesFor(metadata, Role.class);</span><br><span class="line">	<span class="keyword">if</span> (role != <span class="keyword">null</span>) &#123;</span><br><span class="line">		abd.setRole(role.getNumber(<span class="string">"value"</span>).intValue());</span><br><span class="line">	&#125;</span><br><span class="line">       <span class="comment">// 看看有没有@Description注解</span></span><br><span class="line">	AnnotationAttributes description = attributesFor(metadata, Description.class);</span><br><span class="line">	<span class="keyword">if</span> (description != <span class="keyword">null</span>) &#123;</span><br><span class="line">		abd.setDescription(description.getString(<span class="string">"value"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>主要检查了类上面有没有<code>@Lazy</code>，<code>@Primary</code>，<code>@DependsOn</code>，<code>@Role</code>，<code>@Description</code>这几个注解，如果有，则对<code>BeanDefinition</code>进行相应的设置，因为我的<code>Bs.class</code>类上没有上面的注解，所以就什么也不会发生</p>
<ol start="3">
<li><p>看看有没有<code>BeanDefinitionCustomizer</code>，有的话调用它的customize方法</p>
</li>
<li><p>调用<code>AnnotationConfigUtils</code>的applyScopedProxyMode方法，主要作用是把Bean配置成scoped proxy（如果类上有类似<code>@Scope(proxyMode = ScopedProxyMode.TARGET_CLASS)</code>这样的配置），因为我的<code>Bs.class</code>类似没有配置，所以默认是不配置成scoped proxy的，所以这个方法将不会产生任何影响。具体可以看<a href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-other-injection" target="_blank" rel="noopener">Scoped Beans as Dependencies</a></p>
</li>
<li><p>调用<code>BeanDefinitionReaderUtils</code>的registerBeanDefinition方法，其实就是调用<code>BeanDefinitionRegistry</code>的<code>registerBeanDefinition(String beanName, BeanDefinition beanDefinition)</code>方法注册<code>BeanDefinition</code>，在我的程序中，beanName为”bs”，<code>BeanDefinition</code>就是类为<code>Bs.class</code>的<code>BeanDefinition</code></p>
</li>
</ol>
<p>到这里doRegisterBean已经执行完成，<code>AnnotatedBeanDefinitionReader</code>的register方法也执行完成了，<code>AnnotatedBeanDefinitionReader</code>的register方法也执行完成了（因为我只传如了<code>Bs.class</code>，所以只执行一次就完成了）</p>
<h3 id="refresh"><a href="#refresh" class="headerlink" title="refresh()"></a>refresh()</h3><p>执行<code>AnnotationConfigApplicationContext</code>的register方法后，将会执行它的refresh方法。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">		<span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">		prepareRefresh();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">		ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">		prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">			postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">			invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">			registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Initialize message source for this context.</span></span><br><span class="line">			initMessageSource();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">			initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">			onRefresh();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">			registerListeners();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">			finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">			finishRefresh();</span><br><span class="line">		&#125;</span><br><span class="line">		......</span><br><span class="line">		<span class="comment">// 省略了后面的代码</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>refresh方法里面的逻辑十分清晰，按顺序调用了12个方法</p>
<h4 id="1-prepareRefresh"><a href="#1-prepareRefresh" class="headerlink" title="1. prepareRefresh"></a>1. prepareRefresh</h4><p>prepareRefresh方法在<code>AbstractApplicationContext</code>类里面<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">	<span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line">	<span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize any placeholder property sources in the context environment</span></span><br><span class="line">	initPropertySources();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Validate that all properties marked as required are resolvable</span></span><br><span class="line">	<span class="comment">// see ConfigurablePropertyResolver#setRequiredProperties</span></span><br><span class="line">	getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allow for the collection of early ApplicationEvents,</span></span><br><span class="line">	<span class="comment">// to be published once the multicaster is available...</span></span><br><span class="line">	<span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法主要设置了一些相关的属性，比如startupDate，closed等，然后调用了initPropertySources方法（目前这个方法是什么也不做），接着获取<code>Environment</code>实例（如果environment变量为空，则创建一个<code>StandardEnvironment</code>实例），调用<code>Environment</code>的validateRequiredProperties验证所有需要的属性（其实就是检查一下需要属性是否空），最后给earlyApplicationEvents赋值（值为<code>LinkedHashSet</code>实例）。</p>
<p>这里的看不太懂的是获取<code>Environment</code>实例这个步骤，因为从前面的步骤可以看到，这个environment变量属于<code>AbstractApplicationContext</code>类，但是并没有看到它为这个变量赋值，所以它一定是空的，所以一定会调用createEnvironment方法创建一个<code>StandardEnvironment</code>赋值给environment变量。接着看validateRequiredProperties方法，这个方法在<code>AbstractEnvironment</code>类里面<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validateRequiredProperties</span><span class="params">()</span> <span class="keyword">throws</span> MissingRequiredPropertiesException </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.propertyResolver.validateRequiredProperties();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它调用了propertyResolver的.validateRequiredProperties方法，而propertyResolver是这样赋值的：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConfigurablePropertyResolver propertyResolver =</span><br><span class="line">		<span class="keyword">new</span> PropertySourcesPropertyResolver(<span class="keyword">this</span>.propertySources);</span><br></pre></td></tr></table></figure></p>
<p>所以将会调用<code>PropertySourcesPropertyResolver</code>的alidateRequiredProperties方法，而实际上该类并没有这个方法，这个方法是从它的父类<code>AbstractPropertyResolver</code>继承的<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; requiredProperties = <span class="keyword">new</span> LinkedHashSet&lt;&gt;()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validateRequiredProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	MissingRequiredPropertiesException ex = <span class="keyword">new</span> MissingRequiredPropertiesException();</span><br><span class="line">	<span class="keyword">for</span> (String key : <span class="keyword">this</span>.requiredProperties) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.getProperty(key) == <span class="keyword">null</span>) &#123;</span><br><span class="line">			ex.addMissingRequiredProperty(key);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!ex.getMissingRequiredProperties().isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">throw</span> ex;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>AbstractPropertyResolver</code>类里面并没有看到往requiredProperties添加元素的步骤。有一个往requiredProperties添加元素的方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRequiredProperties</span><span class="params">(String... requiredProperties)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (String key : requiredProperties) &#123;</span><br><span class="line">		<span class="keyword">this</span>.requiredProperties.add(key);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个方法设置断点，发现这个方法并没有被调用（所以这个requiredProperties究竟是从什么地方放元素进去的？？？）</p>
<h4 id="2-obtainFreshBeanFactory"><a href="#2-obtainFreshBeanFactory" class="headerlink" title="2. obtainFreshBeanFactory"></a>2. obtainFreshBeanFactory</h4><p>这个方法在<code>AbstractApplicationContext</code>类里面<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	refreshBeanFactory();</span><br><span class="line">	<span class="keyword">return</span> getBeanFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>里面调用了refreshBeanFactory和getBeanFactory方法。<br>先看方法refreshBeanFactory方法，它在<code>GenericApplicationContext</code>类里面（在这个例子中是在这个类里面）<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Do nothing: We hold a single internal BeanFactory and rely on callers</span></span><br><span class="line"><span class="comment"> * to register beans through our public methods (or the BeanFactory's).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #registerBeanDefinition</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">this</span>.refreshed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">				<span class="string">"GenericApplicationContext does not support multiple refresh attempts: just call 'refresh' once"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">this</span>.beanFactory.setSerializationId(getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实就是调用了<code>DefaultListableBeanFactory</code>的setSerializationId方法设置了一个用于序列化的id。<br>接下来看<code>AbstractApplicationContext</code>类的getBeanFactory方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ConfigurableListableBeanFactory <span class="title">getBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException</span>;</span><br></pre></td></tr></table></figure></p>
<p>是个抽象方法，说明是留给子类实现的（模板方法模式），<code>GenericApplicationContext</code>类实现了这个方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ConfigurableListableBeanFactory <span class="title">getBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>直接放回了<code>GenericApplicationContext</code>的beanFactory变量，beanFactory变量已经在<code>GenericApplicationContext</code>的无参构造器里面赋值了，类型是<code>DefaultListableBeanFactory</code></p>
<h4 id="3-prepareBeanFactory"><a href="#3-prepareBeanFactory" class="headerlink" title="3. prepareBeanFactory"></a>3. prepareBeanFactory</h4><p>这个方法在<code>AbstractApplicationContext</code>类里面<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Tell the internal bean factory to use the context's class loader etc.</span></span><br><span class="line">	beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">	beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">	beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Configure the bean factory with context callbacks.</span></span><br><span class="line">	beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line">	beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">	beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">	beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">	beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">	beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">	beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class="line">	<span class="comment">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class="line">	beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">	beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="keyword">this</span>);</span><br><span class="line">	beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="keyword">this</span>);</span><br><span class="line">	beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register early post-processor for detecting inner beans as ApplicationListeners.</span></span><br><span class="line">	beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span></span><br><span class="line">	<span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">		beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">		<span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">		beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register default environment beans.</span></span><br><span class="line">	<span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">		beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">		beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">		beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法做了很多工作</p>
<ul>
<li><p>首先它将<code>BeanFactory</code>的<code>BeanClassLoader</code>设置成和当前<code>ApplicationContext</code>相同的的<code>ClassLoader</code>，<code>BeanExpressionResolver</code>设置成<code>StandardBeanExpressionResolver</code>。</p>
</li>
<li><p>添加<code>PropertyEditorRegistrar</code>（用于注册自定义的<code>PropertyEditor</code>），类型为<code>ResourceEditorRegistrar</code>。</p>
</li>
<li><p>添加<code>BeanPostProcessor</code>，具体类型为<code>ApplicationContextAwareProcessor</code>，用于将<code>ApplicationContext</code>传递到实现了<code>*Aware</code>接口的Bean，它主要实现了<code>BeanPostProcessor</code>的postProcessBeforeInitialization方法，这个方法主要调用了它里面的一个私有方法invokeAwareInterfaces，这个歌方法会判断Bean实例有没有实现<code>*Aware</code>接口，如果有的话则将当前的<code>ApplicationContext</code>赋值到Bean实例里面的applicationContext属性，具体如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareInterfaces</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EnvironmentAware) &#123;</span><br><span class="line">			((EnvironmentAware) bean).setEnvironment(<span class="keyword">this</span>.applicationContext.getEnvironment());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware) &#123;</span><br><span class="line">			((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(<span class="keyword">this</span>.embeddedValueResolver);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ResourceLoaderAware) &#123;</span><br><span class="line">			((ResourceLoaderAware) bean).setResourceLoader(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware) &#123;</span><br><span class="line">			((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MessageSourceAware) &#123;</span><br><span class="line">			((MessageSourceAware) bean).setMessageSource(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationContextAware) &#123;</span><br><span class="line">			((ApplicationContextAware) bean).setApplicationContext(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将<code>*Aware</code>接口设置为不参与自动装配（意思是实现了<code>*Aware</code>接口的类，不会通过自动装配把它们注入到依赖属性里面，但是手动指定依赖关系依然是可以注入的）</p>
</li>
<li><p>将当前的<code>BeanFactory</code>设置成可以配自动装配到类型为<code>BeanFactory</code>的依赖属性中</p>
</li>
<li><p>将当前的<code>AbstractApplicationContext</code>设置成可以被自动装配到类型为<code>ResourceLoader</code>，<code>ApplicationEventPublisher</code>和<code>ApplicationContext</code>的依赖属性中（具体可以看<code>ConfigurableListableBeanFactory</code>的registerResolvableDependency方法上面的注释，这个方法是为了让一些不是Bean的对象也能用于自动装配，比如<code>BeanFactory</code>没有被定义成Bean，为了能让它用于自动装配，即我们调用这个方法让它可以用于自动装配），因为<code>AbstractApplicationContext</code>间接实现了<code>ResourceLoader</code>，<code>ApplicationEventPublisher</code>和<code>ApplicationContext</code>这几个接口，所以可以这样设置。</p>
</li>
<li><p>添加<code>BeanPostProcessor</code>，类型为<code>ApplicationListenerDetector</code>，它的主要作用是检测实现了<code>ApplicationListener</code>接口的Bean，它主要实现了<code>BeanPostProcessor</code>接口的postProcessAfterInitialization方法，在这个方法中，它会判断Bean实例是不是<code>ApplicationListener</code>类型（即是否实现了<code>ApplicationListener</code>接口），如果是，则将其添加到<code>ApplicationContext</code>，具体过程如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationListener) &#123;</span><br><span class="line">		<span class="comment">// potentially not detected as a listener by getBeanNamesForType retrieval</span></span><br><span class="line">		Boolean flag = <span class="keyword">this</span>.singletonNames.get(beanName);</span><br><span class="line">		<span class="keyword">if</span> (Boolean.TRUE.equals(flag)) &#123;</span><br><span class="line">			<span class="comment">// singleton bean (top-level or inner): register on the fly</span></span><br><span class="line">			<span class="keyword">this</span>.applicationContext.addApplicationListener((ApplicationListener&lt;?&gt;) bean);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (Boolean.FALSE.equals(flag)) &#123;</span><br><span class="line">			<span class="keyword">this</span>.singletonNames.remove(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果检测到名称为”loadTimeWeaver”的Bean，就添加<code>BeanPostProcessor</code>，类型为<code>LoadTimeWeaverAwareProcessor</code>，用于动态编入，接着在设置一个临时等等类加载器，类型为<code>ContextTypeMatchClassLoader</code>（具体作用还不清楚）</p>
</li>
<li><p>最后会注册几个默认的<code>Environment</code>类型的Bean，名称分别为”environment”，”systemProperties”和”systemEnvironment”</p>
</li>
</ul>
<h4 id="4-postProcessBeanFactory"><a href="#4-postProcessBeanFactory" class="headerlink" title="4. postProcessBeanFactory"></a>4. postProcessBeanFactory</h4><p>这个方法在<code>AbstractApplicationContext</code>类里面<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Modify the application context's internal bean factory after its standard</span></span><br><span class="line"><span class="comment"> * initialization. All bean definitions will have been loaded, but no beans</span></span><br><span class="line"><span class="comment"> * will have been instantiated yet. This allows for registering special</span></span><br><span class="line"><span class="comment"> * BeanPostProcessors etc in certain ApplicationContext implementations.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanFactory the bean factory used by the application context</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>是一个空方法，注释上说这个方法可以在<code>ApplicatinoContext</code>初始化之后修改它内部的<code>BeanFactory</code>，这时候所有Bean都已经被加载（<code>BeanDefinition</code>都创建好了），但是还没有创建Bean实例，所以在一些特定的<code>ApplicationContext</code>实现中，还能够继续注册特别的<code>BeanPostProcessor</code>这类东西（不是很懂它说的什么，感觉只看最前面那句注释就好了）<br><code>AbstractApplicationContext</code>的子类<code>GenericApplicationContext</code>并没有重写这个方法，<code>AnnotationConfigApplicationContext</code>也没有，所以这个方法在这里是什么也不做的。</p>
<h4 id="5-invokeBeanFactoryPostProcessors"><a href="#5-invokeBeanFactoryPostProcessors" class="headerlink" title="5. invokeBeanFactoryPostProcessors"></a>5. invokeBeanFactoryPostProcessors</h4><p>这个方法在<code>AbstractApplicationContext</code>类里面<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Instantiate and invoke all registered BeanFactoryPostProcessor beans,</span></span><br><span class="line"><span class="comment"> * respecting explicit order if given.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Must be called before singleton instantiation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">	PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></span><br><span class="line">	<span class="comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></span><br><span class="line">	<span class="keyword">if</span> (beanFactory.getTempClassLoader() == <span class="keyword">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">		beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">		beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法的名字非常直观，一眼就可以看出它是用来调用<code>BeanFactoryPostProcessor</code>的（注释上说是实例化并调用全部已经注册的<code>BeanFactoryPostProcessor</code>类型的Bean，调用的意思是调用<code>BeanFactoryPostProcessor</code>接口里面的方法）</p>
<p>它调用了<code>PostProcessorRegistrationDelegate</code>的invokeBeanFactoryPostProcessors方法，这个方法有点长，所以就不贴出来了，可以自己去看源码<br>它的主要逻辑如下：</p>
<ul>
<li>首先调用<code>BeanDefinitionRegistryPostProcessor</code>（如果存在的话），<br><code>BeanDefinitionRegistryPostProcessor</code>肯定是存在的，原因是在前面<code>AnnotatedBeanDefinitionReader</code>的doRegisterBean方法执行的时候，注册了几个PostProcessor，其中注册的第一个就是<code>ConfigurationClassPostProcessor</code>，它实现了<code>BeanDefinitionRegistryPostProcessor</code>接口<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationClassPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span>,</span></span><br><span class="line"><span class="class">		<span class="title">PriorityOrdered</span>, <span class="title">ResourceLoaderAware</span>, <span class="title">BeanClassLoaderAware</span>, <span class="title">EnvironmentAware</span></span>&#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> <span class="keyword">extends</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Modify the application context's internal bean definition registry after its</span></span><br><span class="line"><span class="comment">	 * standard initialization. All regular bean definitions will have been loaded,</span></span><br><span class="line"><span class="comment">	 * but no beans will have been instantiated yet. This allows for adding further</span></span><br><span class="line"><span class="comment">	 * bean definitions before the next post-processing phase kicks in.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> registry the bean definition registry used by the application context</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> org.springframework.beans.BeansException in case of errors</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>所以首先会调用<code>ConfigurationClassPostProcessor</code>实现的的postProcessBeanDefinitionRegistry方法。怎么调用它的postProcessBeanDefinitionRegistry方法呢？前面好像只注册了它的<code>BeanDefinition</code>，还没有创建相应的Bean实例。实际上在调用它的方法前会调用<code>BeanFactory</code>的getBean方法，这个方法会获取它的Bean实例，因为实例还没创建，所以会先创建Bean实例，具体的逻辑如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] postProcessorNames =</span><br><span class="line">		beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">	<span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">		<span class="comment">// 下面调用了BeanFactory的getBean方法，这个方法会获取BeanDefinitionRegistryPostProcessor的实例</span></span><br><span class="line">		<span class="comment">// 如果没有获取到（这里还没创建，所以是肯定获取不到的），则会创建它的实例</span></span><br><span class="line">		currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">		processedBeans.add(ppName);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接着后面就能遍历processedBeans遍历，调用里面的实例的postProcessBeanDefinitionRegistry方法了</span></span><br></pre></td></tr></table></figure></p>
<p><code>ConfigurationClassPostProcessor</code>实现的的postProcessBeanDefinitionRegistry方法会调用它的processConfigBeanDefinitions方法，这个方法也是非常的长，所以也不贴出来了。但是这个方法非常的重要，因为它包含了解析我们的<code>@Configguration</code>和<code>@Bean</code>注解的逻辑，实际上它就是用来解析<code>@Configuration</code>类的（具体的实现逻辑可以去看源码，在<code>ConfigurationClassPostProcessor</code>类的processConfigBeanDefinitions里面）。</p>
<p>– 先调用实现了<code>PriorityOrdered</code>接口的<code>BeanDefinitionRegistryPostProcessor</code> （这里其实会调用<code>ConfigurationClassPostProcessor</code>类实现的postProcessBeanDefinitionRegistry，后面其实已经没有其他的<code>BeanDefinitionRegistryPostProcessor</code>可以调用了）<br>– 接着调用实现了<code>Order</code>接口的<code>BeanDefinitionRegistryPostProcessor</code><br>– 最后调用其它的所有<code>BeanDefinitionRegistryPostProcessor</code></p>
<ul>
<li>调用<code>BeanFactoryPostProcessor</code>（实际上到这里只剩下<code>EventListenerMethodProcessor</code>了，后面只会调用它，它是用来处理<code>@EventListener</code>注解的）<br>– 先调用实现了<code>PriorityOrdered</code>接口的<code>BeanFactoryPostProcessor</code><br>– 接着调用实现了<code>Order</code>接口的<code>BeanFactoryPostProcessor</code><br>– 最后调用其它的所有<code>BeanFactoryPostProcessor</code></li>
</ul>
<p>调用完<code>PostProcessorRegistrationDelegate</code>会进行一些和动态织入相关的设置</p>
<h4 id="6-registerBeanPostProcessors"><a href="#6-registerBeanPostProcessors" class="headerlink" title="6. registerBeanPostProcessors"></a>6. registerBeanPostProcessors</h4><p>这个方法在<code>AbstractApplicationContext</code>类里面<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">	PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它的主要作用是注册<code>BeanPostProcessor</code>，<code>BeanPostProcessor</code>用于在创建Bean的实例时候对Bean进行一些处理（比如覆盖实例化Bean的默认逻辑，添加自己解析Bean依赖的逻辑），该方法调用了<code>PostProcessorRegistrationDelegate</code>的registerBeanPostProcessors方法，逻辑和上面的调用invokeBeanFactoryPostProcessors方法是类似的<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register BeanPostProcessorChecker that logs an info message when</span></span><br><span class="line">	<span class="comment">// a bean is created during BeanPostProcessor instantiation, i.e. when</span></span><br><span class="line">	<span class="comment">// a bean is not eligible for getting processed by all BeanPostProcessors.</span></span><br><span class="line">	<span class="keyword">int</span> beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + <span class="number">1</span> + postProcessorNames.length;</span><br><span class="line">	beanFactory.addBeanPostProcessor(<span class="keyword">new</span> BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Separate between BeanPostProcessors that implement PriorityOrdered,</span></span><br><span class="line">	<span class="comment">// Ordered, and the rest.</span></span><br><span class="line">	List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">		<span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">			priorityOrderedPostProcessors.add(pp);</span><br><span class="line">			<span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">				internalPostProcessors.add(pp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">			orderedPostProcessorNames.add(ppName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// First, register the BeanPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">	sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">	registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Next, register the BeanPostProcessors that implement Ordered.</span></span><br><span class="line">	List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">		BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">		orderedPostProcessors.add(pp);</span><br><span class="line">		<span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">			internalPostProcessors.add(pp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">	registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Now, register all regular BeanPostProcessors.</span></span><br><span class="line">	List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">		BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">		nonOrderedPostProcessors.add(pp);</span><br><span class="line">		<span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">			internalPostProcessors.add(pp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Finally, re-register all internal BeanPostProcessors.</span></span><br><span class="line">	sortPostProcessors(internalPostProcessors, beanFactory);</span><br><span class="line">	registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Re-register post-processor for detecting inner beans as ApplicationListeners,</span></span><br><span class="line">	<span class="comment">// moving it to the end of the processor chain (for picking up proxies etc).</span></span><br><span class="line">	beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(applicationContext));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>注册一个<code>BeanPostProcessor</code>，具体类型为<code>BeanPostProcessorChecker</code>，用于记录Bean被实例化的时候的info级别的日志</li>
<li>注册实现了<code>PriorityOrdered</code>接口的<code>BeanPostProcessor</code>（这里将会注册<code>AutowiredAnnotationBeanPostProcessor</code>和<code>CommonAnnotationBeanPostProcessor</code>，之前只是注册它们的<code>BeanDefinitino</code>，这里是把它们注册为<code>BeanPostProcessor</code>）</li>
<li>注册实现了<code>Order</code>接口的<code>BeanPostProcessor</code>（没有这样的<code>BeanPostProcessor</code>）</li>
<li>注册常规的，也就是没有实现<code>PriorityOrdered</code>和<code>Order</code>接口的<code>BeanPostProcessor</code>（这里也没有这样的<code>BeanPostProcessor</code>）</li>
<li>重写注册所有内部的<code>BeanPostProcessor</code>（<code>MergedBeanDefinitionPostProcessor</code>类型的<code>BeanPostProcessor</code>，这里只有<code>AutowiredAnnotationBeanPostProcessor</code>和<code>CommonAnnotationBeanPostProcessor</code>符合）</li>
<li>重新注册一个<code>BeanPostProcessor</code>，类型为<code>ApplicationListenerDetector</code>（用于自动检测实现了<code>ApplicationListener</code>接口的Bean），注释上说这样操作后这个<code>BeanPostProcessor</code>就会被移动到processor调用链的后面</li>
</ul>
<h4 id="7-initMessageSource"><a href="#7-initMessageSource" class="headerlink" title="7. initMessageSource"></a>7. initMessageSource</h4><p>这个方法在<code>AbstractApplicationContext</code>类里面<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the MessageSource.</span></span><br><span class="line"><span class="comment"> * Use parent's if none defined in this context.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initMessageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">	<span class="keyword">if</span> (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) &#123;</span><br><span class="line">		<span class="keyword">this</span>.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);</span><br><span class="line">		<span class="comment">// Make MessageSource aware of parent MessageSource.</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.messageSource <span class="keyword">instanceof</span> HierarchicalMessageSource) &#123;</span><br><span class="line">			HierarchicalMessageSource hms = (HierarchicalMessageSource) <span class="keyword">this</span>.messageSource;</span><br><span class="line">			<span class="keyword">if</span> (hms.getParentMessageSource() == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">// Only set parent context as parent MessageSource if no parent MessageSource</span></span><br><span class="line">				<span class="comment">// registered already.</span></span><br><span class="line">				hms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">"Using MessageSource ["</span> + <span class="keyword">this</span>.messageSource + <span class="string">"]"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Use empty MessageSource to be able to accept getMessage calls.</span></span><br><span class="line">		DelegatingMessageSource dms = <span class="keyword">new</span> DelegatingMessageSource();</span><br><span class="line">		dms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">		<span class="keyword">this</span>.messageSource = dms;</span><br><span class="line">		beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, <span class="keyword">this</span>.messageSource);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主要用来初始化<code>MessageSource</code>，<code>MessageSource</code>是用来支持国际化（多语言）的，里面的getMessage方法可以出解析不同地区支持的语言。但是好像并没有看到在什么地方有注册这种类型的Bean，所以应该是要自己手动添加的。它先在当前<code>BeanFactory</code>查找 名称为”messagegSource”的Bean(只在当前的<code>BeanFactory</code>查找，找不到也不会往父<code>BeanFactory</code>查找)，当然，在这个例子中是找不到的，因为没有配置这样的Bean。</p>
<p>我们假设已经配置了这样的Bean，然后找到了这样的Bean，接着会检查当前的<code>ApplicatinoContext</code>是不是有父<code>ApplicatinoContext</code>并且找到的<code>MessaegSource</code>为<code>HierarchicalMessageSource</code>类型，如果是，检查<code>MessaegSource</code>的父级<code>MessaegSource</code>是不是为空，如果是，则讲个它自身设置为父级<code>MessaegSource</code>。</p>
<p>如果没有找到这样的Bean，则会创建一个类型为<code>DelegatingMessageSource</code>的<code>MessaegSource</code>，然后设置父级<code>MessaegSource</code>为getInternalParentMessageSource获取到的<code>MessaegSource</code>，在本例中应该是null，接着将刚刚创建的<code>MessaegSource</code>注册为单例Bean，名称为”messaggeSource”</p>
<h4 id="8-initApplicationEventMulticaster"><a href="#8-initApplicationEventMulticaster" class="headerlink" title="8. initApplicationEventMulticaster"></a>8. initApplicationEventMulticaster</h4><p>这个方法在<code>AbstractApplicationContext</code>类里面<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the ApplicationEventMulticaster.</span></span><br><span class="line"><span class="comment"> * Uses SimpleApplicationEventMulticaster if none defined in the context.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.event.SimpleApplicationEventMulticaster</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationEventMulticaster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">	<span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line">		<span class="keyword">this</span>.applicationEventMulticaster =</span><br><span class="line">				beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">"Using ApplicationEventMulticaster ["</span> + <span class="keyword">this</span>.applicationEventMulticaster + <span class="string">"]"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">this</span>.applicationEventMulticaster = <span class="keyword">new</span> SimpleApplicationEventMulticaster(beanFactory);</span><br><span class="line">		beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="keyword">this</span>.applicationEventMulticaster);</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">"No '"</span> + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + <span class="string">"' bean, using "</span> +</span><br><span class="line">					<span class="string">"["</span> + <span class="keyword">this</span>.applicationEventMulticaster.getClass().getSimpleName() + <span class="string">"]"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主要用来初始化<code>ApplicationEventMulticaster</code>，<code>ApplicationEventMulticaster</code>是用来管理<code>ApplicationListener</code>的（里面有addApplicationListener，removeApplicationListener等方法），能够向<code>ApplicationListener</code>发布事件（调用multicastEvent方法），<code>ApplicationEventPublisher</code>（一般是<code>ApplicationContext</code>，因为它继承了<code>ApplicationEventPublisher</code>）通常使用<code>ApplicationEventMulticaster</code>作为代理发布事件（意思是直接调用<code>ApplicationEventMulticaster</code>的方法发布事件，不自己实现发布事件的逻辑）。</p>
<p>首先该方法在当前的<code>BeanFactory</code>中查找名称为”applicationEventMulticaster”的<code>ApplicationEventMulticaster</code>（只在当前级别的<code>BeanFactory</code>查找，不向父级查找），当然，是本例中，找不到的，因为默认没有配置。</p>
<p>如果找到了，这将这个Bean赋值给applicationEventMulticaster变量。</p>
<p>如果没找到，则创建一个<code>SimpleApplicationEventMulticaster</code>类型的<code>ApplicationEventMulticaster</code>赋值给applicationEventMulticaster变量，然后注册为单例Bean，名称为”applicationEventMulticaster”</p>
<h4 id="9-onRefresh"><a href="#9-onRefresh" class="headerlink" title="9. onRefresh"></a>9. onRefresh</h4><p>这个方法在<code>AbstractApplicationContext</code>类里面<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">	<span class="comment">// For subclasses: do nothing by default.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>目前不进行任何操作</p>
<ol start="10">
<li>registerListeners<br>这个方法在<code>AbstractApplicationContext</code>类里面<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Register statically specified listeners first.</span></span><br><span class="line">	<span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">		getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">	<span class="comment">// uninitialized to let post-processors apply to them!</span></span><br><span class="line">	String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">	<span class="keyword">for</span> (String listenerBeanName : listenerBeanNames) &#123;</span><br><span class="line">		getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Publish early application events now that we finally have a multicaster...</span></span><br><span class="line">	Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="keyword">this</span>.earlyApplicationEvents;</span><br><span class="line">	<span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (earlyEventsToProcess != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</span><br><span class="line">			getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>该方法会注册<code>ApplicationListener</code>（包括配置了Bean的和没有配置的，没有配置的就是注释里面说的statically specified listeners）。</p>
<ul>
<li><p>首先将调用<code>ApplicationEventMulticaster</code>（实际的类型为<code>SimpleApplicationEventMulticaster</code>，其实就是上面的initApplicationEventMulticaster方法刚刚创建的那个）的addApplicationListener方法（这个方法实际上是在<code>AbstractApplicationEventMulticaster</code>实现的）把statically specified listeners（实际上就是<code>AbstractApplicationContext</code>的applicationListeners变量的值）添加进去</p>
</li>
<li><p>然后和上面类似，把所有<code>ApplicationListener</code>类型的Bean添加进去（不一样的是这里是调用addApplicationListenerBean方法）</p>
</li>
<li><p>将earlyApplicationEvents变量里面存储的<code>ApplicationEvent</code>通过<code>SimpleApplicationEventMulticaster</code>的multicastEvent方法发布出去</p>
</li>
</ul>
<h4 id="11-finishBeanFactoryInitialization"><a href="#11-finishBeanFactoryInitialization" class="headerlink" title="11. finishBeanFactoryInitialization"></a>11. finishBeanFactoryInitialization</h4><p>这个方法在<code>AbstractApplicationContext</code>类里面<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line">	<span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">			beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">		beanFactory.setConversionService(</span><br><span class="line">				beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line">	<span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">	<span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">	<span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">		beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line">	String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">	<span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">		getBean(weaverAwareName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">	beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line">	beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">	beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法会将完成当前<code>ApplicationContext</code>的<code>BeanFactory</code>的初始化，把所有非延迟加载的单例singleton beans实例化。我觉得这是12个方法里面最复杂的方法了，主要步骤如下：</p>
<ul>
<li><p>查找名称为”conversionService”且类型为<code>ConversionService</code>的Bean，如果有，则调用<code>BeanFactory</code>的setConversionService进行设置(<code>ConversionService</code>是用来进行类型转换的)</p>
</li>
<li><p>如果没有找到默认的embedded value resolver（在本例中，它是用来解析注解的属性值的），则马上添加一个（添加的resolve其实是<code>PropertySourcesPropertyResolver</code>）</p>
</li>
<li><p>初始化所有实现了<code>LoadTimeWeaverAware</code>接口的Bean，注释上说尽快初始化这些Bean，以便他们能够尽快地注册transformers（不是很懂）</p>
</li>
<li><p>停用临时的类加载器</p>
</li>
<li><p>调用<code>BeanFactory</code>的freezeConfiguration来防止配置的变动，使得<code>BeanDefinition</code>元数据能够被缓存</p>
</li>
<li><p>调用<code>BeanFactory</code>的preInstantiateSingletons方法实例化所有的非延迟加载的singleton beans</p>
</li>
</ul>
<p>重点看preInstantiateSingletons方法（在<code>DefaultListableBeanFactory</code>里面）<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">	<span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">	List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line">	<span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">		RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">		<span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">				Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">				<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">					<span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">					<span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">					<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">						isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">										((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">								getAccessControlContext());</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">								((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">						getBean(beanName);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				getBean(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line">	<span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">		Object singletonInstance = getSingleton(beanName);</span><br><span class="line">		<span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">			<span class="keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">			<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">				AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">					smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">				&#125;, getAccessControlContext());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主要分为两步</p>
<ul>
<li><p>初始化所有非延迟加载的singleton beans（创建Bean实例）<br><strong> 如果这个Bean是<code>FactoryBean</code>(特殊类型的Bean，用于创建其它复杂的Bean)，则把beanName加上<code>&amp;</code>前缀（具体为什么要这样做后面会讲到），再调用getBean方法获取Bean实例，判断获取到的实例是不是<code>FactoryBean</code>类型，如果是，将它转换成<code>SmartFactoryBean</code>调用isEagerInit方法，如果返回true，就调用getBean方法（这次传入的参数是beanName，没有加<code>&amp;</code>前缀）
</strong> 如果这个Bean不是<code>FactoryBean</code>，直接调用getBean方法（如果Bean实例还没有创建的话，getBean方法会创建该实例）</p>
</li>
<li><p>调用所有实现了<code>SmartInitializingSingleton</code>接口的Bean的afterSingletonsInstantiated方法</p>
</li>
</ul>
<p>接着来看gegtBean方法，getBean方法在<code>AbstractBeanFactory</code>里面<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>getBean方法里面调用了doGetBean方法，具体的实现逻辑应该就在doGetBean方法里面了（代码非常多，这里就不贴出来了），主要的逻辑如下：</p>
<ul>
<li>调用transformedBeanName方法把传入的beanName开头的<code>&amp;</code>字符全部去除</li>
<li>调用getSingleton方法先从手动注册的单例缓存里面获取实例</li>
<li>如果前面获取得到了实例，并且没有其他额外的参数传入，则调用getObjectForBeanInstance方法获取Bean实例，否则进行下面的操作</li>
<li>parentBeanFactory不为空的话，就调用parentBeanFactory的getBean方法，传进去的beanName为原始的beanName，即未调用transformedBeanName方法前的beanName</li>
<li>如果parentBeanFactory为空，或者parentBeanFactory调用完getBean方法后依然没有获取到Bean实例，则使用当前的<code>BeanFactory</code>获取Bean实例</li>
<li>调用getMergedLocalBeanDefinition方法获取<code>RootBeanDefinition</code>，并调用checkMergedBeanDefinition方法检验</li>
<li>调用<code>RootBeanDefinition</code>的getDependsOn方法检测是否依赖于其它的Bean，如果是，则先注册并创建依赖的Bean的实例</li>
<li>根据Bean的Scope(作用域)，使用不同的逻辑创建Bean的实例<br><strong> 如果Scope为Singleton（Spring的Bean默认的Scope是Singleton），则调用getSingleton方法获取/创建Bean实例（如果Bean实例已经存在了，直接返回，否者就创建一个），获取的Bean实例可能是一个<code>BeanFactory</code>，所以还需要调用getObjectForBeanInstance方法，判断是不是<code>BeanFactory</code>，如果是，则调用<code>FactoryBean</code>的getObject方法获取真正的Bean实例（其实这里面的逻辑非常复杂繁琐，但是最终都会调用<code>FactoryBean</code>的getObject方法，当然前提是要获取不是这个<code>FactoryBean</code>，而是<code>FactoryBean</code>里面创建的Bean实例，即beanName没有<code>&amp;</code>前缀）
</strong> 如果Scope为Prototype，则每次都必定会创建一个新的Bean实例，具体是先调用createBean方法，再调用getObjectForBeanInstance方法获取真正要获取的Bean实例<br><strong> 如果Scope为其他类型，则调用<code>Scope</code>的get方法获取/创建Bean实例（具体取决于<code>Scope</code>的类型），再调用getObjectForBeanInstance方法获取真正要获取的Bean实例（创建Scope类型为非Singleton类型的Bean实例的前后会分别调用beforePrototypeCreation和afterPrototypeCreation方法）。
</strong> 最后如果getBean方法指定了Bean实例的类型（参数里面的requiredType），则要进行相应的类型转换<br>** 返回Bean实例</li>
</ul>
<p>再来看看createBean方法，可以看到创建Bean实例的时候都是调用的这个方法，这个方法的具体实现在<code>AbstractAutowireCapableBeanFactory</code>类中<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">		logger.trace(<span class="string">"Creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Make sure bean class is actually resolved at this point, and</span></span><br><span class="line">	<span class="comment">// clone the bean definition in case of a dynamically resolved Class</span></span><br><span class="line">	<span class="comment">// which cannot be stored in the shared merged bean definition.</span></span><br><span class="line">	Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">	<span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">		mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">		mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Prepare method overrides.</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		mbdToUse.prepareMethodOverrides();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">				beanName, <span class="string">"Validation of method overrides failed"</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">		Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">		<span class="comment">// 如果bean不为null，说明已经可能已经创建了一个代理类实例，不需要往下执行了，直接返回该实例</span></span><br><span class="line">		<span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> bean;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">				<span class="string">"BeanPostProcessor before instantiation of bean failed"</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 如果上面resolveBeforeInstantiation方法返回null，则执行doCreateBean方法创建Bean实例</span></span><br><span class="line">		Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> beanInstance;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">		<span class="comment">// A previously detected exception with proper bean creation context already,</span></span><br><span class="line">		<span class="comment">// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.</span></span><br><span class="line">		<span class="keyword">throw</span> ex;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">				mbdToUse.getResourceDescription(), beanName, <span class="string">"Unexpected exception during bean creation"</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主要步骤如下：</p>
<ul>
<li>调用resolveBeanClass方法根据<code>RootBeanDefinition</code>和beanName解析出要创建的Bean的实例对应的类</li>
<li>把<code>RootBeanDefinition</code>复制一份，因为后面<code>RootBeanDefinition</code>可能会被修改，而后面还有用到原<code>RootBeanDefinition</code>的信息</li>
<li>调用<code>RootBeanDefinition</code>（实际上是<code>AbstractBeanDefinition</code>）的prepareMethodOverrides方法，配置好要重写的方法</li>
<li>调用resolveBeforeInstantiation方法，这会调用所有实现了<code>InstantiationAwareBeanPostProcessor</code>接口（该接口为<code>BeanPostProcessor</code>的子接口）的<code>BeanPostProcessor</code>，通常用于创建一个代理类实例，而非Bean实例，如果返回<code>null</code>，则继续执行下面的doCreateBean方法，否者将直接返回实例</li>
<li>如果上面的resolveBeforeInstantiation返回<code>null</code>，则调用doCreateBean方法执行具体的创建Bean实例的逻辑</li>
</ul>
<p>具体的创建Bean实例的逻辑在doCreateBean方法里面<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">       <span class="comment">// 省略了catch块里面的代码</span></span><br><span class="line">	<span class="comment">// Instantiate the bean.</span></span><br><span class="line">	BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">		instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">		instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">	Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">	<span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">		mbd.resolvedTargetType = beanType;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">	<span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			&#125;</span><br><span class="line">			mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">	<span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">	<span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">			isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">	<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">		addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize the bean instance.</span></span><br><span class="line">	Object exposedObject = bean;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">		exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">		Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">				exposedObject = earlySingletonReference;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">				String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">				Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">				<span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">					<span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">						actualDependentBeans.add(dependentBean);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register bean as disposable.</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主要步骤如下：</p>
<ul>
<li><p>调用createBeanInstance方法创建<code>BeanWrapper</code>实例，具体创建步骤如下：<br><strong> 如果Bean配置了使用工厂方法创建Bean实例，则使用工厂方法创建
</strong> 判断构造器或者工厂方法是否已经被解析，如果是，且构造器的参数也已经被解析，调用相应的构造器注入依赖并初始化Bean实例，如果构造器的参数没有被解析，则调用无参构造器实例化Bean<br><strong> 这里开始解析构造器或者工厂方法，判断是否有多个构造参数满足条件，这里将调用determineConstructorsFromBeanPostProcessors方法决定使用哪一个构造器
</strong> 如果无法决定使用哪一个构造器，则查看是否设置了要优先使用的构造器，如果有，则使用该构造器创建Bean实例<br>** 上面的各种条件都不满足的话，就使用无参构造器创建Bean实例，将调用instantiateBean方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">instantiateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Object beanInstance;</span><br><span class="line">		<span class="keyword">final</span> BeanFactory parent = <span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			beanInstance = AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt;</span><br><span class="line">					getInstantiationStrategy().instantiate(mbd, beanName, parent),</span><br><span class="line">					getAccessControlContext());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 这里的getInstantiationStrategy为CglibSubclassingInstantiationStrategy</span></span><br><span class="line">			<span class="comment">// 但是调用的instantiate方法是SimpleInstantiationStrategy的</span></span><br><span class="line">			<span class="comment">// 一般最后会调用BeanUtils的instantiateClass方法，使用JDK的反射机制创建实例</span></span><br><span class="line">			<span class="comment">// 或者调用的CglibSubclassingInstantiationStrategy的instantiateWithMethodInjection方法，</span></span><br><span class="line">			<span class="comment">// 这样会使用Cglib来创建实例</span></span><br><span class="line">			beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">		&#125;</span><br><span class="line">		BeanWrapper bw = <span class="keyword">new</span> BeanWrapperImpl(beanInstance);</span><br><span class="line">		initBeanWrapper(bw);</span><br><span class="line">		<span class="keyword">return</span> bw;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">				mbd.getResourceDescription(), beanName, <span class="string">"Instantiation of bean failed"</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上面创建了Bean实例，而且可能已经通过构造器注入了一些必要的依赖。接下来会调用applyMergedBeanDefinitionPostProcessors方法，这会使得所有的类型为<code>MergedBeanDefinitionPostProcessor</code>的postProcessor被调用</p>
</li>
<li>判断当前创建的Bean实例的能否被提前缓存起来，以解决循环引用的问题</li>
<li>调用populateBean方法根据<code>RootBeanDefinition</code>填充Bean实例的属性</li>
<li><p>调用initializeBean方法初始化Bean实例，这会调用各种<code>*Aware</code>方法（比如BeanNameAware, BeanFactoryAware），<code>BeanPostProcessor</code>方法，<code>InitializingBean</code>方法等，具体的<a href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/factory/BeanFactory.html" target="_blank" rel="noopener">顺序</a>如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. BeanNameAware&apos;s setBeanName</span><br><span class="line">2. BeanClassLoaderAware&apos;s setBeanClassLoader</span><br><span class="line">3. BeanFactoryAware&apos;s setBeanFactory</span><br><span class="line">4. EnvironmentAware&apos;s setEnvironment</span><br><span class="line">5. EmbeddedValueResolverAware&apos;s setEmbeddedValueResolver</span><br><span class="line">6. ResourceLoaderAware&apos;s setResourceLoader (only applicable when running in an application context)</span><br><span class="line">7. ApplicationEventPublisherAware&apos;s setApplicationEventPublisher (only applicable when running in an application context)</span><br><span class="line">8. MessageSourceAware&apos;s setMessageSource (only applicable when running in an application context)</span><br><span class="line">9. ApplicationContextAware&apos;s setApplicationContext (only applicable when running in an application context)</span><br><span class="line">10. ServletContextAware&apos;s setServletContext (only applicable when running in a web application context)</span><br><span class="line">11. postProcessBeforeInitialization methods of BeanPostProcessors</span><br><span class="line">12. InitializingBean&apos;s afterPropertiesSet</span><br><span class="line">13. a custom init-method definition</span><br><span class="line">14. postProcessAfterInitialization methods of BeanPostProcessors</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>if (earlySingletonExposure)</code>这一步里面代码的暂时还看不懂</p>
</li>
<li>调用registerDisposableBeanIfNecessary方法，注册实现了<code>DestructionAwareBeanPostProcessor</code>和<code>DisposableBean</code>接口或者自定义了destroy方法的Bean</li>
<li>返回创建的Bean实例</li>
</ul>
<h4 id="12-finishRefresh"><a href="#12-finishRefresh" class="headerlink" title="12. finishRefresh"></a>12. finishRefresh</h4><p>这个方法在<code>AbstractApplicationContext</code>类里面<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Clear context-level resource caches (such as ASM metadata from scanning).</span></span><br><span class="line">	clearResourceCaches();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize lifecycle processor for this context.</span></span><br><span class="line">	initLifecycleProcessor();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Propagate refresh to lifecycle processor first.</span></span><br><span class="line">	getLifecycleProcessor().onRefresh();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Publish the final event.</span></span><br><span class="line">	publishEvent(<span class="keyword">new</span> ContextRefreshedEvent(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Participate in LiveBeansView MBean, if active.</span></span><br><span class="line">	LiveBeansView.registerApplicationContext(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主要用来发布事件，同时也做了一些其它的事情：</p>
<ol>
<li><p>调用clearResourceCaches方法（<code>this.resourceCaches.clear()</code>），注释上说是用来清楚资源缓存的，比如ASM扫描产生的元数据</p>
</li>
<li><p>调用initLifecycleProcessor方法，这是用来初始化<code>LifecycleProcessor</code>的，<code>LifecycleProcessor</code>用来检测所有实现了<code>LifeCycle</code>接口的Bean，然后使得<code>LifeCycle</code>里面的方法能够在相应的阶段被执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initLifecycleProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">	<span class="keyword">if</span> (beanFactory.containsLocalBean(LIFECYCLE_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">		<span class="keyword">this</span>.lifecycleProcessor =</span><br><span class="line">				beanFactory.getBean(LIFECYCLE_PROCESSOR_BEAN_NAME, LifecycleProcessor.class);</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">"Using LifecycleProcessor ["</span> + <span class="keyword">this</span>.lifecycleProcessor + <span class="string">"]"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		DefaultLifecycleProcessor defaultProcessor = <span class="keyword">new</span> DefaultLifecycleProcessor();</span><br><span class="line">		defaultProcessor.setBeanFactory(beanFactory);</span><br><span class="line">		<span class="keyword">this</span>.lifecycleProcessor = defaultProcessor;</span><br><span class="line">		beanFactory.registerSingleton(LIFECYCLE_PROCESSOR_BEAN_NAME, <span class="keyword">this</span>.lifecycleProcessor);</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">"No '"</span> + LIFECYCLE_PROCESSOR_BEAN_NAME + <span class="string">"' bean, using "</span> +</span><br><span class="line">					<span class="string">"["</span> + <span class="keyword">this</span>.lifecycleProcessor.getClass().getSimpleName() + <span class="string">"]"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这个方法和之前分析的initMessageSource、initApplicationEventMulticaster等方法都是类似的，首先该会在当前的<code>ApplicationContext</code>查找名称为lifecycleProcessor的Bean，一般没有手动配置的话是找不到的，所以会创建一个<code>DefaultLifecycleProcessor</code>类型的lifecycleProcessor（在spring context包下只找到了这一个具体实现类），这个类实现了<code>BeanFactoryAware</code>接口，因此能够被注入<code>BeanFactory</code>，然后使用<code>BeanFactory</code>（实际上是<code>ListableBeanFactory</code>）的getBeanNamesForType方法获取所有实现了<code>LifeCycle</code>接口的Bean的名称，然后再用这些名称获取到相应的Bean<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Map&lt;String, Lifecycle&gt; <span class="title">getLifecycleBeans</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">	Map&lt;String, Lifecycle&gt; beans = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">	<span class="comment">// 调用ListableBeanFactory的getBeanNamesForType获取实现了LifeCycle接口的所有beanName</span></span><br><span class="line">	String[] beanNames = beanFactory.getBeanNamesForType(Lifecycle.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">	<span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">		String beanNameToRegister = BeanFactoryUtils.transformedBeanName(beanName);</span><br><span class="line">		<span class="comment">// 有可能是一个FactoryBean，如果是，则在beanName前面加上&amp;前缀</span></span><br><span class="line">		<span class="keyword">boolean</span> isFactoryBean = beanFactory.isFactoryBean(beanNameToRegister);</span><br><span class="line">		String beanNameToCheck = (isFactoryBean ? BeanFactory.FACTORY_BEAN_PREFIX + beanName : beanName);</span><br><span class="line">		<span class="keyword">if</span> ((beanFactory.containsSingleton(beanNameToRegister) &amp;&amp;</span><br><span class="line">				(!isFactoryBean || matchesBeanType(Lifecycle.class, beanNameToCheck, beanFactory))) ||</span><br><span class="line">				matchesBeanType(SmartLifecycle.class, beanNameToCheck, beanFactory)) &#123;</span><br><span class="line">			Object bean = beanFactory.getBean(beanNameToCheck);</span><br><span class="line">			<span class="keyword">if</span> (bean != <span class="keyword">this</span> &amp;&amp; bean <span class="keyword">instanceof</span> Lifecycle) &#123;</span><br><span class="line">				beans.put(beanNameToRegister, (Lifecycle) bean);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> beans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为什么如果Bean是<code>FactoryBean</code>类型的时候，要在beanName前面加上<code>&amp;</code>前缀然后再调用getBean方法呢？<br>这是因为，当使用getBean(String name)方法去获取Bean实例的时候，如果要获取的Bean是<code>FactoryBean</code>类型的，不加<code>&amp;</code>前缀调用getBean方法，将得到这个<code>FactoryBean</code>的getObject方法返回的实例，如果要获取这个<code>FactoryBean</code>的Bean实例，需要在加上<code>&amp;</code>前缀才行，<a href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/factory/BeanFactory.html#FACTORY_BEAN_PREFIX" target="_blank" rel="noopener">这里</a>有讲到</p>
<ol start="3">
<li>调用<code>LifecycleProcessor</code>的onRefresh方法，在这个例子中就是<code>DefaultLifecycleProcessor</code>的onRefresh方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	startBeans(<span class="keyword">true</span>);</span><br><span class="line">	<span class="keyword">this</span>.running = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBeans</span><span class="params">(<span class="keyword">boolean</span> autoStartupOnly)</span> </span>&#123;</span><br><span class="line">	Map&lt;String, Lifecycle&gt; lifecycleBeans = getLifecycleBeans();</span><br><span class="line">	Map&lt;Integer, LifecycleGroup&gt; phases = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	lifecycleBeans.forEach((beanName, bean) -&gt; &#123;</span><br><span class="line">		<span class="keyword">if</span> (!autoStartupOnly || (bean <span class="keyword">instanceof</span> SmartLifecycle &amp;&amp; ((SmartLifecycle) bean).isAutoStartup())) &#123;</span><br><span class="line">			<span class="keyword">int</span> phase = getPhase(bean);</span><br><span class="line">			LifecycleGroup group = phases.get(phase);</span><br><span class="line">			<span class="keyword">if</span> (group == <span class="keyword">null</span>) &#123;</span><br><span class="line">				group = <span class="keyword">new</span> LifecycleGroup(phase, <span class="keyword">this</span>.timeoutPerShutdownPhase, lifecycleBeans, autoStartupOnly);</span><br><span class="line">				phases.put(phase, group);</span><br><span class="line">			&#125;</span><br><span class="line">			group.add(beanName, bean);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="keyword">if</span> (!phases.isEmpty()) &#123;</span><br><span class="line">		List&lt;Integer&gt; keys = <span class="keyword">new</span> ArrayList&lt;&gt;(phases.keySet());</span><br><span class="line">		Collections.sort(keys);</span><br><span class="line">		<span class="keyword">for</span> (Integer key : keys) &#123;</span><br><span class="line">			phases.get(key).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>获取所有实现了<code>LifeCycle</code>接口的Bean</li>
<li>继续筛选出所有支持自启动的Bean，然后获取它们的阶段值，根据它们的阶段值分组</li>
<li>如果上面筛选出的分组不为空，则对分组进行排序，然后按顺序调用每一组（<code>LifecycleGroup</code>）的start方法</li>
<li>设置running变量为true</li>
</ul>
<ol start="4">
<li><p>发布一个<code>ContextRefreshedEvent</code>类型的事件（表示<code>ApplicationContext</code>已经被初始化和刷新完成）。实际上会调用<code>ApplicationEventMulticaster</code>的multicastEvent方法来发送事件，如果有父<code>ApplicationContext</code>的话，还好调用父<code>ApplicationContext</code>的publishEvent方法来发送事件。</p>
</li>
<li><p>调用<code>LiveBeansView</code>的registerApplicationContext方法，这个方法做的事情有点抽象</p>
</li>
</ol>
<ul>
<li>从<code>Environment</code>中获取一个名称为”spring.liveBeansView.mbeanDomain”的属性的值，如果有这个属性，则进行下面的步骤，否则什么也不做</li>
<li>判断applicationContexts集合里面是不是有元素，如过有元素，则直接进行下面的步骤，如果没有元素<br><strong> 调用<code>ManagementFactory</code>的getPlatformMBeanServer方法获取<code>MBeanServer</code>实例
</strong> 将<code>LiveBeansView</code>的applicationName变量赋值为当前的<code>ApplicationContext</code>的applicationName<br>** 调用<code>MBeanServer</code>实例的registerMBean方法，</li>
<li>把当前的<code>ApplicationContext</code>加到<code>LiveBeansView</code>的applicationContexts集合中（<code>Set&lt;ConfigurableApplicationContext&gt;</code>类型）</li>
</ul>

                <hr>
                

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2018/12/29/Spring-EnableAsync-注解原理/" data-toggle="tooltip" data-placement="top"
                           title="Spring @EnableAsync 注解原理">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2018/12/23/spring-boot自动配置原理/" data-toggle="tooltip" data-placement="top"
                           title="spring-boot自动配置原理">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                

                


                <!--加入新的评论系统-->
                
                <!-- 来必力City版安装代码 -->
                <div id="lv-container" data-id="city" data-uid="MTAyMC8zODUyNi8xNTA1NA==">
                    <script type="text/javascript">
                        (function(d, s) {
                            var j, e = d.getElementsByTagName(s)[0];

                            if (typeof LivereTower === 'function') { return; }

                            j = d.createElement(s);
                            j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                            j.async = true;

                            e.parentNode.insertBefore(j, e);
                        })(document, 'script');
                    </script>
                    <noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
                </div>
                <!-- City版安装代码已完成 -->
                
            </div>

            <div class="hidden-xs col-sm-3 toc-col">
                <div class="toc-wrap">
                    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#几个重要的接口"><span class="toc-text">几个重要的接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanFactory"><span class="toc-text">BeanFactory</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ListableBeanFactory"><span class="toc-text">ListableBeanFactory</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HierarchicalBeanFactory"><span class="toc-text">HierarchicalBeanFactory</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AutowireCapableBeanFactory"><span class="toc-text">AutowireCapableBeanFactory</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ApplicationContext"><span class="toc-text">ApplicationContext</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ConfigurableApplicationContext"><span class="toc-text">ConfigurableApplicationContext</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanDefinition"><span class="toc-text">BeanDefinition</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanDefinitionRegistry"><span class="toc-text">BeanDefinitionRegistry</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanFactoryPostProcessor"><span class="toc-text">BeanFactoryPostProcessor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanPostProcessor"><span class="toc-text">BeanPostProcessor</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建ApplicationContext"><span class="toc-text">创建ApplicationContext</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#this"><span class="toc-text">this.()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#register-Class-lt-gt-…-annotatedClasses"><span class="toc-text">register(Class&lt;?&gt;… annotatedClasses)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#refresh"><span class="toc-text">refresh()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-prepareRefresh"><span class="toc-text">1. prepareRefresh</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-obtainFreshBeanFactory"><span class="toc-text">2. obtainFreshBeanFactory</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-prepareBeanFactory"><span class="toc-text">3. prepareBeanFactory</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-postProcessBeanFactory"><span class="toc-text">4. postProcessBeanFactory</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-invokeBeanFactoryPostProcessors"><span class="toc-text">5. invokeBeanFactoryPostProcessors</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-registerBeanPostProcessors"><span class="toc-text">6. registerBeanPostProcessors</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-initMessageSource"><span class="toc-text">7. initMessageSource</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-initApplicationEventMulticaster"><span class="toc-text">8. initApplicationEventMulticaster</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-onRefresh"><span class="toc-text">9. onRefresh</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-finishBeanFactoryInitialization"><span class="toc-text">11. finishBeanFactoryInitialization</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-finishRefresh"><span class="toc-text">12. finishRefresh</span></a></li></ol></li></ol></li></ol>
                </div>
            </div>
        </div>

        <div class="row">
            <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5 class="text-center">
                        <a href="/Tags/">FEATURED TAGS</a>
                    </h5>
                    <div class="tags">
                        
                        <a class="tag" href="/Tags/#Spring"
                           title="Spring">Spring</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <div style="margin-top: 20px;">
                    <h5 class="text-center">FRIENDS</h5>
                    <ul class="list-inline text-center">
                        
                        <li><a href="https://echi.me">echisan</a></li>
                        
                    </ul>
                </div>
                
            </div>
        </div>

    </div>
</article>







<!-- Footer -->
<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <br>
                <ul class="list-inline text-center">
                
                
                    <li>
                        <a target="_blank" href="https://twitter.com/plentymorea">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/plentymore">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; PLTM 2021
                    <br>
                    <span id="busuanzi_container_site_pv" style="font-size: 12px;">PV: <span id="busuanzi_value_site_pv"></span> Times</span>
                    <br>
                    <br>
                    Theme by <a href="https://github.com/Haojen/hexo-theme-Anisina">Haojen Ma</a>
                </p>

            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/blog.js"></script>

<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://plentymore.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>

<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-123175280-1';
    var _gaDomain = 'plentymore.github.io';
    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>


<!-- Baidu Tongji -->


<!-- swiftype -->
<!-- <script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','','2.0.0');
</script> -->

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<!--wechat title img-->
<img class="wechat-title-img" src="https://avatars3.githubusercontent.com/u/30522768?s=400&amp;u=a2ce54d7c63789391a0ba32b17792b7a21d64fbb&amp;v=4">
</body>

</html>
